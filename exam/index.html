<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Watch</title>
    <style>
        body{background:#000;color:white;font-family:'Segoe UI',Arial,sans-serif;display:flex;justify-content:center;align-items:center;height:100vh;margin:0;overflow:auto;user-select:none}
        .watch-container{width:300px;height:300px;background:linear-gradient(145deg,#1a1a1a,#0a0a0a);border-radius:25px;border:3px solid #333;display:flex;flex-direction:column;justify-content:center;align-items:center;position:relative;box-shadow:0 0 20px rgba(0,0,0,0.8),inset 0 1px 2px rgba(255,255,255,0.1);transition: all 0.4s ease-in-out;}
        /* --- NEW: Style for the circular view --- */
        .watch-container.circular-view {
            border-radius: 50%;
        }
        #clock{font-size:2.8rem;font-family:'Courier New',monospace;text-align:center;letter-spacing:2px;color:#00ff88;text-shadow:0 0 10px rgba(0,255,136,0.3);margin-bottom:8px;font-weight:300;transition:all 0.3s ease}
        #date{font-size:1.1rem;opacity:0.8;color:#888;margin-bottom:15px;font-weight:300;transition:all 0.3s ease}
        #battery{position:absolute;top:15px;right:20px;font-size:0.8rem;color:#00ff88;opacity:0.7}
        #ai-response{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:85%;text-align:center;font-size:1rem;line-height:1.3;opacity:0;visibility:hidden;transition:all 0.3s ease;word-wrap:break-word;max-height:220px;overflow-y:auto;color:#fff;z-index:10}
        #ai-response.visible{opacity:1;visibility:visible}
        #map-display{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:90%;height:90%;opacity:0;visibility:hidden;transition:all 0.3s ease;z-index:10;border-radius:15px;overflow:hidden;cursor:pointer}
        #map-display.visible{opacity:1;visibility:visible}
        #map-display img{width:100%;height:100%;object-fit:contain;border-radius:15px}
        .status-dot{position:absolute;top:15px;left:20px;width:8px;height:8px;background:#888;border-radius:50%;transition:all 0.3s ease}
        .status-dot.active{background:#00ff88;animation:pulse 2s infinite}
        .status-dot.listening{background:#0066ff;animation:pulse 0.5s infinite}
        .status-dot.heard{background:#ff9900;animation:flash 0.2s 2} /* --- LED FIX: Flashes orange twice --- */
        .status-dot.sent{background:#00ff88;animation:none} /* --- LED FIX: Solid green --- */
        .status-dot.mode-change{background:#ff0000;animation:flash 0.3s 2}
        .status-dot.model-change{background:#ff00ff;animation:flash 0.3s 3}
        @keyframes pulse{0%,100%{opacity:0.6}50%{opacity:1}}
        @keyframes flash{0%,100%{opacity:0.3}50%{opacity:1}}
        #ai-response::-webkit-scrollbar{width:2px}
        #ai-response::-webkit-scrollbar-track{background:rgba(255,255,255,0.1);border-radius:2px}
        #ai-response::-webkit-scrollbar-thumb{background:rgba(0,255,136,0.5);border-radius:2px}
        .watch-bezel{position:absolute;top:5px;left:5px;right:5px;bottom:5px;border:1px solid #444;border-radius:20px;pointer-events:none}
        .watch-bezel.scrolling{animation:bezel-flash 0.5s ease-out}
        @keyframes bezel-flash{0%,100%{border-color:#444}50%{border-color:#00ff88;box-shadow:0 0 5px #00ff88}}
        .time-markers{position:absolute;width:100%;height:100%}
        .marker{position:absolute;background:#333;opacity:0.5}
        .marker.hour{width:2px;height:12px}
        .marker:nth-child(1){top:8px;left:50%;transform:translateX(-50%)}
        .marker:nth-child(2){top:50%;right:8px;transform:translateY(-50%)}
        .marker:nth-child(3){bottom:8px;left:50%;transform:translateX(-50%)}
        .marker:nth-child(4){top:50%;left:8px;transform:translateY(-50%)}
        .hidden{opacity:0!important;visibility:hidden!important}
        #model-indicator{position:absolute;bottom:15px;right:20px;font-size:0.7rem;color:#666;opacity:0.8}
        .model-list{text-align:left;font-size:0.9rem;line-height:1.6}
        .model-list .current{color:#00ff88;font-weight:bold}
        .spelling-display{font-size:1.8rem;line-height:1.3;color:#00ff88;text-align:center;font-family:'Courier New',monospace;letter-spacing:3px;font-weight:800;text-shadow:0 0 10px rgba(0,255,136,0.4), 0 0 20px rgba(0,255,136,0.2);text-transform:uppercase;animation:spellingGlow 2s ease-in-out infinite alternate}
        @keyframes spellingGlow{0%{text-shadow:0 0 10px rgba(0,255,136,0.4), 0 0 20px rgba(0,255,136,0.2)}100%{text-shadow:0 0 15px rgba(0,255,136,0.6), 0 0 25px rgba(0,255,136,0.3)}}
        .spelling-word{color:#fff;margin-bottom:10px;font-size:4rem;font-weight:bold}
    </style>
</head>
<body>
    <div class="watch-container" id="watchContainer">
        <div class="watch-bezel" id="watchBezel"></div>
        <div class="time-markers">
            <div class="marker hour"></div>
            <div class="marker hour"></div>
            <div class="marker hour"></div>
            <div class="marker hour"></div>
        </div>
        <div class="status-dot" id="statusDot"></div>
        <div id="battery">85%</div>
        <div id="model-indicator">M4</div>
        <div id="clock"></div>
        <div id="date"></div>
        <div id="ai-response"></div>
        <div id="map-display">
            <img src="https://raw.githubusercontent.com/Success009/portfolio/refs/heads/main/exam/new-political-map-of-Nepal-1024x678.jpg" alt="Nepal Political Map">
        </div>
    </div>

    <script>
        let currentMode='english',sharedMemory=[],recognition,isHolding=false,holdTimeout,isResponseVisible=false,isMapVisible=false,batteryLevel=85,micActive=false,isProcessing=false,currentModelIndex=3,isCircularView=false;
        let answerHistory = [];
        let currentHistoryIndex = -1;
        let apiAbortController;
        const clock=document.getElementById('clock'),date=document.getElementById('date'),aiResponse=document.getElementById('ai-response'),mapDisplay=document.getElementById('map-display'),battery=document.getElementById('battery'),watchContainer=document.getElementById('watchContainer'),statusDot=document.getElementById('statusDot'),modelIndicator=document.getElementById('model-indicator'),watchBezel=document.getElementById('watchBezel');

        const apiKeys = [
            'AIzaSyCVhh967ATShWvPX0jjh2sbruzWTxEGXL4',
            'AIzaSyAydVv1BnKnKIsjXkBqqlqC3YJ8Z7R2J2c',
            'AIzaSyBfsnu2FEGgCha2Q2W6-pRJEh4xU0prjZY'
        ];
        let currentApiKeyIndex = 0;

        const aiModels = [
            { name: 'gemini-2.5-pro', displayName: 'gemini-2.5-pro', indicator: 'M1' },
            { name: 'gemini-2.5-flash', displayName: 'gemini-2.5-flash', indicator: 'M2' },
            { name: 'gemini-1.5-pro', displayName: 'gemini-1.5-pro', indicator: 'M3' },
            { name: 'gemini-1.5-flash', displayName: 'gemini-1.5-flash', indicator: 'M4' },
            { name: 'gemini-1.5-flash-latest', displayName: 'gemini-1.5-flash-latest', indicator: 'M5' }
        ];

        function loadPreferences() {
            const savedApiIndex = localStorage.getItem('smartwatch_api_key_index');
            const savedModelIndex = localStorage.getItem('smartwatch_model_index');
            
            if (savedApiIndex !== null) {
                currentApiKeyIndex = parseInt(savedApiIndex);
                console.log(`üì¶ Loaded API Key Index: ${currentApiKeyIndex + 1}/${apiKeys.length}`);
            }
            
            if (savedModelIndex !== null) {
                currentModelIndex = parseInt(savedModelIndex);
                console.log(`üì¶ Loaded Model Index: ${currentModelIndex + 1}/${aiModels.length} (${aiModels[currentModelIndex].displayName})`);
            }
            
            updateModelIndicator();
        }

        function savePreferences() {
            localStorage.setItem('smartwatch_api_key_index', currentApiKeyIndex.toString());
            localStorage.setItem('smartwatch_model_index', currentModelIndex.toString());
        }

        function updateModelIndicator() {
            modelIndicator.textContent = aiModels[currentModelIndex].indicator;
        }

        // --- UPGRADE: Removed Nepali localization from notifications ---
        function showApiChangeNotification() {
            const message = `API Changed (${currentApiKeyIndex + 1}/${apiKeys.length})`;
            displayResponse(message, false);
            setTimeout(() => {
                if (aiResponse.innerHTML === message) {
                    hideResponse();
                }
            }, 2000);
        }

        function showModelChangeNotification() {
            statusDot.className = 'status-dot model-change';
            const modelName = aiModels[currentModelIndex].displayName;
            const message = `Model Changed: ${modelName}`;
            displayResponse(message, false);
            setTimeout(() => {
                statusDot.className = micActive ? 'status-dot active' : 'status-dot';
                if (aiResponse.innerHTML === message) {
                    hideResponse();
                }
            }, 2500);
        }

        function displayModels() {
            let modelList = '';
            aiModels.forEach((model, index) => {
                const isCurrent = index === currentModelIndex;
                const prefix = isCurrent ? `<span class="current">${index + 1}  ${model.displayName}</span>` : `${index + 1}  ${model.displayName}`;
                modelList += prefix + '\n';
            });
            
            displayResponse(`<div class="model-list">${modelList}</div>`);
        }

        function selectModel(modelNumber) {
            const index = modelNumber - 1;
            if (index >= 0 && index < aiModels.length) {
                currentModelIndex = index;
                updateModelIndicator();
                savePreferences();
                showModelChangeNotification();
                console.log(`ü§ñ Model changed to: ${aiModels[currentModelIndex].displayName}`);
            }
        }
        
        function displaySpelling(word) {
            const cleanWord = word.trim().toLowerCase();
            hideMap();
            const spellingHtml = `<div class="spelling-display">${cleanWord}</div>`;
            displayResponse(spellingHtml);
            console.log(`‚úèÔ∏è Spelling displayed: ${cleanWord}`);
        }

        function updateTime(){
            const now=new Date();
            clock.textContent=now.toLocaleTimeString('en-US',{hour12:false,hour:'2-digit',minute:'2-digit'});
            date.textContent=now.toLocaleDateString('en-US',{weekday:'short',month:'short',day:'numeric'});
            if(Math.random()<0.001){
                batteryLevel=Math.max(20,batteryLevel-1);
                battery.textContent=`${batteryLevel}%`;
            }
        }

        function switchMode(){
            currentMode=currentMode==='english'?'nepali':'english';
            statusDot.className='status-dot mode-change';
            setTimeout(()=>{
                statusDot.className=micActive?'status-dot active':'status-dot';
                if(recognition){
                    recognition.stop();
                    setTimeout(()=>{if(micActive)initSpeechRecognition()},500);
                }
            },600);
        }
        
        async function tryApiRequest(fullQuery, apiKey) {
            const currentModel = aiModels[currentModelIndex].name;
            apiAbortController = new AbortController();
            updateStatus('sent'); // LED STATUS: Solid Green
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${currentModel}:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: fullQuery }] }]
                }),
                signal: apiAbortController.signal
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            return response;
        }

        async function getAIResponse(question, language) {
            try {
                const memoryContext = sharedMemory.length > 0 ? `Context: [${sharedMemory.join(", ")}]. ` : "";
                const languageInstruction = language === 'nepali' ? "Respond only in Nepali language." : "Respond only in English language.";
                const fullQuery = `${memoryContext}${languageInstruction} Core rules:
                - For formulas, reply only with the formula from Nepal's Class 10 Sangam Book. But give answer even if it is different.
                - For dates, search online and provide the most accurate date with a confidence level.
                - For grammar tasks (e.g. question tag, passive, indirect, tense, etc.), reply with the correct transformed sentence only, as per Nepal Class 10 English rules. Interpret bracketed hints as instructions.
                - For all else, respond clearly and concisely.
                - If I ask you full form fine from class 10 Nepal sangam publication, If you don't know the exact contents of the book, just provide a correct answer.
                Question: ${question}`;
                
                console.log(`ü§ñ AI Request (${language}) using ${aiModels[currentModelIndex].displayName}:`, question);
                console.log(`üîë Using API Key Index: ${currentApiKeyIndex + 1}/${apiKeys.length}`);

                let response;
                let attempts = 0;
                const maxAttempts = apiKeys.length;

                while (attempts < maxAttempts) {
                    try {
                        response = await tryApiRequest(fullQuery, apiKeys[currentApiKeyIndex]);
                        break;
                    } catch (error) {
                        if (error.name === 'AbortError') { return null; }
                        console.log(`‚ùå API Key ${currentApiKeyIndex + 1} failed:`, error.message);
                        
                        if (error.message.includes('429')) {
                            console.log(`üîÑ Switching to next API key due to rate limit...`);
                            currentApiKeyIndex = (currentApiKeyIndex + 1) % apiKeys.length;
                            savePreferences();
                            attempts++;
                            showApiChangeNotification();
                            if (attempts < maxAttempts) {
                                console.log(`üîë Trying API Key Index: ${currentApiKeyIndex + 1}/${apiKeys.length}`);
                                continue;
                            }
                        } else { throw error; }
                    }
                }

                if (!response) { throw new Error('All API keys exhausted due to rate limits'); }

                const data = await response.json();
                const aiAnswer = data.candidates[0].content.parts[0].text.trim();
                
                console.log(`ü§ñ AI Response:`, aiAnswer);
                console.log(`‚úÖ Successfully used API Key Index: ${currentApiKeyIndex + 1} with Model: ${aiModels[currentModelIndex].displayName}`);
                return aiAnswer;
            } catch (error) {
                if (error.name === 'AbortError') { return null; }
                console.log(`ü§ñ AI Error:`, error.message);
                
                if (error.message.includes('All API keys exhausted')) {
                    return "All API keys rate limited. Please try again later.";
                } else {
                    return "Service unavailable.";
                }
            }
        }

        function displayResponse(text, addToHistory = true){
            hideMap();
            if (addToHistory && text) {
                answerHistory.unshift(text);
                if (answerHistory.length > 20) answerHistory.pop();
                currentHistoryIndex = 0;
            }
            aiResponse.innerHTML = text;
            aiResponse.classList.add('visible');
            clock.classList.add('hidden');
            date.classList.add('hidden');
            isResponseVisible = true;
            aiResponse.scrollTop = 0;
        }

        function displayAnswerFromHistory(index) {
            if (answerHistory.length > 0 && index >= 0 && index < answerHistory.length) {
                currentHistoryIndex = index;
                displayResponse(answerHistory[index], false);
                console.log(`üìö Displaying answer from history, index: ${index}`);
            } else {
                console.log(`üìö History navigation limit reached.`);
                const message = 'No older answers.';
                displayResponse(message, false);
                 setTimeout(() => {
                    if (currentHistoryIndex !== -1 && answerHistory[currentHistoryIndex]) {
                        displayResponse(answerHistory[currentHistoryIndex], false);
                    } else if (answerHistory.length > 0) {
                        displayResponse(answerHistory[0], false);
                    } else {
                        hideResponse();
                    }
                }, 1500);
            }
        }

        function hideResponse(){
            aiResponse.classList.remove('visible');
            clock.classList.remove('hidden');
            date.classList.remove('hidden');
            isResponseVisible=false;
        }

        function displayMap(){
            hideResponse();
            mapDisplay.classList.add('visible');
            clock.classList.add('hidden');
            date.classList.add('hidden');
            isMapVisible=true;
            console.log('üó∫Ô∏è Map displayed');
        }

        function hideMap(){
            mapDisplay.classList.remove('visible');
            if(!isResponseVisible){
                clock.classList.remove('hidden');
                date.classList.remove('hidden');
            }
            isMapVisible=false;
        }

        function scrollResponse(direction){
            if(!isResponseVisible) return;
            watchBezel.classList.add('scrolling');
            setTimeout(() => watchBezel.classList.remove('scrolling'), 500);

            const lineHeight=parseInt(window.getComputedStyle(aiResponse).lineHeight)||20;
            const scrollAmount=lineHeight*3;
            if(direction==='down'){
                aiResponse.scrollTop+=scrollAmount;
            }else if(direction==='up'){
                aiResponse.scrollTop-=scrollAmount;
            }
        }
        
        // --- NEW: Function to toggle the circular view ---
        function toggleCircularView() {
            isCircularView = !isCircularView;
            watchContainer.classList.toggle('circular-view');

            let confirmationMessage;
            if (isCircularView) {
                const size = Math.min(window.innerHeight, window.innerWidth) * 0.9;
                watchContainer.style.width = `${size}px`;
                watchContainer.style.height = `${size}px`;
                console.log(`üîÑ View changed to circular (${size}px)`);
                confirmationMessage = "Circular view activated.";
            } else {
                watchContainer.style.width = '';
                watchContainer.style.height = '';
                console.log('üîÑ View changed back to default');
                confirmationMessage = "Default view restored.";
            }
            
            displayResponse(confirmationMessage, false);
            setTimeout(() => {
                if (aiResponse.innerHTML === confirmationMessage) {
                   hideResponse();
                }
            }, 2000);
        }

        function updateStatus(status){
            statusDot.className=`status-dot ${status}`;
        }

        function toggleMic(){
            if(isProcessing)return;
            micActive=!micActive;
            if(micActive){
                updateStatus('active');
                initSpeechRecognition();
            }else{
                updateStatus('');
                if(recognition)recognition.stop();
            }
        }

        function checkVoiceCommands(transcript){
            const lowerTranscript=transcript.toLowerCase();
            
            if(lowerTranscript.includes("display view in circle")){
                console.log("üé§ Voice Command: Display View in Circle");
                toggleCircularView();
                return true;
            }
            if(lowerTranscript.includes("display answer")){
                console.log("üé§ Voice Command: Display Answer");
                displayAnswerFromHistory(0);
                return true;
            }
            if(lowerTranscript.includes("previous answer")){
                console.log("üé§ Voice Command: Previous Answer");
                displayAnswerFromHistory(currentHistoryIndex + 1);
                return true;
            }
            if(lowerTranscript.includes("next answer")){
                console.log("üé§ Voice Command: Next Answer");
                displayAnswerFromHistory(currentHistoryIndex - 1);
                return true;
            }
            if(lowerTranscript.includes("display map")){
                console.log("üé§ Voice Command: Display Map");
                displayMap();
                return true;
            }
            if(lowerTranscript.includes("scroll down")){
                console.log("üé§ Voice Command: Scroll Down");
                scrollResponse('down');
                return true;
            }
            if(lowerTranscript.includes("scroll up")){
                console.log("üé§ Voice Command: Scroll Up");
                scrollResponse('up');
                return true;
            }
            if(lowerTranscript.includes("spelling of")){
                const word = transcript.replace(/spelling of\s+/i, "").trim();
                if(word) {
                    console.log(`üé§ Voice Command: Spelling of "${word}"`);
                    displaySpelling(word);
                }
                return true;
            }
            if(lowerTranscript.includes("display models")){
                console.log("üé§ Voice Command: Display Models");
                displayModels();
                return true;
            }
            const selectModelMatch = lowerTranscript.match(/select model (one|first|second|third|fourth|fifth|\d+)/);
            if (selectModelMatch) {
                const identifier = selectModelMatch[1];
                const ordinals = { 'one': 1, 'first': 1, 'second': 2, 'third': 3, 'fourth': 4, 'fifth': 5 };
                let modelNumber = ordinals[identifier] || parseInt(identifier);
                if (!isNaN(modelNumber)) {
                    console.log(`üé§ Voice Command: Select Model ${modelNumber} (from "${identifier}")`);
                    selectModel(modelNumber);
                    return true;
                }
            }
            if(lowerTranscript.includes("remember ")){
                const memoryContent=transcript.replace(/remember\s+/i,"").trim();
                if(memoryContent){
                    sharedMemory.push(memoryContent);
                    if(sharedMemory.length>15)sharedMemory.shift();
                    console.log("üß† Memory Added:", memoryContent);
                    displayResponse(`Remembered: "${memoryContent}"`);
                }
                return true;
            }  
            if(lowerTranscript.includes("clear memory")){
                sharedMemory=[];
                console.log("üß† Memory Cleared");
                displayResponse("Memory cleared.");
                return true;
            }
            return false;
        }

        // --- LED FIX: Rewritten for perfect state transitions ---
        function initSpeechRecognition(){
            if(!micActive||!('webkitSpeechRecognition' in window)&&!('SpeechRecognition' in window))return;
            recognition=new(window.SpeechRecognition||window.webkitSpeechRecognition)();
            recognition.continuous=true;
            recognition.interimResults=false;
            recognition.lang=currentMode==='nepali'?'ne-NP':'en-US';

            recognition.onstart = () => updateStatus('listening'); // LED: Blinking Blue

            recognition.onresult = (event)=>{
                const transcript=event.results[event.results.length-1][0].transcript.trim();
                isProcessing = true;
                updateStatus('heard'); // LED: Flash Orange Twice

                // Wait for the orange flash to finish before sending the request
                setTimeout(async () => {
                    if (!isProcessing) return; // In case it was cancelled during the flash

                    if(checkVoiceCommands(transcript)){
                        isProcessing = false;
                        updateStatus(micActive?'active':'');
                        return;
                    }

                    let question = '';
                    if(currentMode === 'nepali' && transcript.includes('‡§Æ‡§≤‡§æ‡§à ‡§≠‡§®')){
                        question = transcript.replace(/‡§Æ‡§≤‡§æ‡§à ‡§≠‡§®/gi,'').trim();
                    } else if (transcript.toLowerCase().startsWith('listen')) {
                        question = transcript.substring('listen'.length).trim();
                    }

                    if (question) {
                        console.log(`üé§ Question (${currentMode} Mode): ${question}`);
                        const answer = await getAIResponse(question, currentMode);
                        if (answer !== null) displayResponse(answer);
                    }
                    
                    isProcessing = false;
                    updateStatus(micActive?'active':''); // LED: Back to Pulsing Green
                }, 400); // 400ms = 2 flashes of 0.2s
            };

            recognition.onerror=()=>{
                isProcessing = false;
                updateStatus(micActive?'active':'');
            };

            recognition.onend=()=>{
                if(micActive&&!isHolding){
                    setTimeout(()=>{
                        if(micActive && !isProcessing) try{ recognition.start() } catch(e){}
                    }, 500);
                }else{
                    updateStatus(micActive?'active':'');
                }
            };

            try{recognition.start()}catch(e){}
        }

        mapDisplay.addEventListener('click', function() {
            hideMap();
        });

        let touchStartTime=0;
        function startHold(e){
            e.preventDefault();
            isHolding=true;
            touchStartTime=Date.now();
            holdTimeout=setTimeout(()=>{
                if(isHolding)switchMode();
            },5000);
        }

        function endHold(e){
            e.preventDefault();
            isHolding=false;
            if(holdTimeout)clearTimeout(holdTimeout);
            const holdDuration=Date.now()-touchStartTime;
            if(holdDuration<500){
                if (isProcessing) {
                    if (apiAbortController) apiAbortController.abort();
                    isProcessing = false;
                    updateStatus(micActive ? 'active' : ''); // LED: Back to Pulsing Green
                    console.log('üö´ User tapped to cancel processing.');
                    return;
                }
                if(isResponseVisible){ hideResponse(); }
                else if(isMapVisible){ hideMap(); }
                else{ toggleMic(); }
            }
        }

        watchContainer.addEventListener('touchstart',startHold,{passive:false});
        watchContainer.addEventListener('touchend',endHold,{passive:false});
        watchContainer.addEventListener('touchcancel',endHold,{passive:false});
        watchContainer.addEventListener('mousedown',startHold);
        watchContainer.addEventListener('mouseup',endHold);
        watchContainer.addEventListener('mouseleave',endHold);
        watchContainer.addEventListener('contextmenu',e=>e.preventDefault());

        function init(){
            loadPreferences();
            updateTime();
            setInterval(updateTime,1000);
            console.log(`üöÄ Smart Watch initialized with ${apiKeys.length} API keys and ${aiModels.length} AI models`);
            console.log(`üîë Starting with API Key Index: ${currentApiKeyIndex + 1}/${apiKeys.length}`);
            console.log(`ü§ñ Starting with Model: ${aiModels[currentModelIndex].displayName} (${aiModels[currentModelIndex].indicator})`);
            console.log(`üöÄ Default model set to: gemini-1.5-flash (Model 4)`);
            console.log(`üó∫Ô∏è Map display feature enabled`);
            console.log(`‚úèÔ∏è Enhanced spelling command feature enabled with bold display`);
        }
        init();
    </script>
</body>
</html>
