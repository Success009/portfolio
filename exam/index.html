<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Watch</title>
    <style>
        :root {
            --transition-speed: 0.6s;
            --transition-curve: cubic-bezier(0.34, 1.56, 0.64, 1); /* Bouncy, organic feel */
        }
        body{background:#000;color:white;font-family:'Segoe UI',Arial,sans-serif;display:flex;justify-content:center;align-items:center;height:100vh;margin:0;overflow:auto;user-select:none}
        .watch-container{width:300px;height:300px;background:linear-gradient(145deg,#1a1a1a,#0a0a0a);border-radius:25px;border:3px solid #333;display:flex;flex-direction:column;justify-content:center;align-items:center;position:relative;box-shadow:0 0 20px rgba(0,0,0,0.8),inset 0 1px 2px rgba(255,255,255,0.1);transition:border-radius var(--transition-speed) ease-in-out, width 0.4s ease, height 0.4s ease;overflow:hidden}
        
        /* --- CORE UI ELEMENTS --- */
        #clock{font-size:2.8rem;font-family:'Courier New',monospace;text-align:center;letter-spacing:2px;color:#00ff88;text-shadow:0 0 10px rgba(0,255,136,0.3);font-weight:300;transition:transform var(--transition-speed) var(--transition-curve)}
        #date{font-size:0.9rem;opacity:0.8;color:#888;font-weight:300;position:absolute;top:32%;left:50%;transform:translateX(-50%);transition:opacity 0.3s ease, transform var(--transition-speed) var(--transition-curve);letter-spacing:1px}
        #date-svg{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;visibility:hidden;transition:opacity 0.3s ease}
        #date-svg text{font-family:'Segoe UI',Arial,sans-serif;font-weight:300;font-size:14px;letter-spacing:2.5px;fill:#888}
        
        /* --- ADAPTIVE INDICATORS --- 
           Using Top/Left percentages for everything ensures smooth sliding animations 
           between Square and Circular positions. 
        */
        
        /* 1. Battery */
        #battery{position:absolute;font-size:0.8rem;color:#00ff88;opacity:0.7;transition:all var(--transition-speed) var(--transition-curve);transform: translate(-50%, -50%);}
        /* Square: Top Right */
        .watch-container:not(.circular-view) #battery { top: 8%; left: 88%; }
        /* Circle: Bottom Right Curve */
        .watch-container.circular-view #battery { top: 78%; left: 80%; }

        /* 2. Status Dot */
        .status-dot{position:absolute;width:8px;height:8px;background:#888;border-radius:50%;transition:all var(--transition-speed) var(--transition-curve);transform: translate(-50%, -50%);}
        /* Square: Top Left */
        .watch-container:not(.circular-view) .status-dot { top: 8%; left: 8%; }
        /* Circle: Bottom Left Curve */
        .watch-container.circular-view .status-dot { top: 78%; left: 20%; }

        /* 3. Model Indicator */
        #model-indicator{position:absolute;font-size:0.7rem;color:#666;opacity:0.8;transition:all var(--transition-speed) var(--transition-curve);transform: translate(-50%, -50%);white-space:nowrap;}
        /* Square: Bottom Right */
        .watch-container:not(.circular-view) #model-indicator { top: 92%; left: 85%; }
        /* Circle: Bottom Center */
        .watch-container.circular-view #model-indicator { top: 85%; left: 50%; }


        /* --- AI & MAP DISPLAYS --- */
        #ai-response{position:absolute;top:55%;left:50%;transform:translate(-50%,-50%) scale(0.95);width:85%;text-align:center;font-size:1rem;line-height:1.3;opacity:0;visibility:hidden;transition:all var(--transition-speed) var(--transition-curve), font-size 0.2s ease;word-wrap:break-word;max-height:60%;overflow-y:auto;color:#fff;z-index:10;background:rgba(10,10,10,0.5);border-radius:15px;padding:10px;box-sizing:border-box}
        #map-display{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:90%;height:90%;opacity:0;visibility:hidden;transition:all var(--transition-speed) var(--transition-curve);z-index:10;border-radius:15px;overflow:hidden;cursor:pointer}
        #map-display img{width:100%;height:100%;object-fit:cover;border-radius:15px;transition:border-radius var(--transition-speed) var(--transition-curve)}
        .spelling-display{font-size:1.8rem;line-height:1.3;color:#00ff88;text-align:center;font-family:'Courier New',monospace;letter-spacing:3px;font-weight:800;text-shadow:0 0 10px rgba(0,255,136,0.4), 0 0 20px rgba(0,255,136,0.2);text-transform:uppercase;animation:spellingGlow 2s ease-in-out infinite alternate}

        /* --- UI STATE MANAGEMENT (Content Hiding/Moving) --- */
        .watch-container.ai-visible #clock, .watch-container.map-visible #clock {transform:translateY(-120px) scale(0.5)}
        .watch-container.ai-visible #date, .watch-container.map-visible #date, .watch-container.ai-visible #date-svg, .watch-container.map-visible #date-svg {opacity:0;transform:translateY(-120px)}
        
        /* When AI/Map is visible, move indicators out of the way */
        .watch-container.ai-visible #battery, .watch-container.map-visible #battery,
        .watch-container.ai-visible #model-indicator, .watch-container.map-visible #model-indicator,
        .watch-container.ai-visible .status-dot, .watch-container.map-visible .status-dot {opacity:0;transform:translate(-50%, 60px)}
        
        .watch-container.ai-visible #ai-response {opacity:1;visibility:visible;transform:translate(-50%,-50%) scale(1)}
        .watch-container.map-visible #map-display {opacity:1;visibility:visible}
        
        .watch-bezel{position:absolute;top:5px;left:5px;right:5px;bottom:5px;border:1px solid #444;border-radius:20px;pointer-events:none;transition:border-radius var(--transition-speed) ease-in-out}
        
        /* --- STATUS DOT ANIMATIONS --- */
        .status-dot.active{background:#00ff88;animation:pulse 2s infinite}
        .status-dot.listening{background:#0066ff;animation:pulse 0.5s infinite}
        .status-dot.heard{background:#ff9900;animation:flash 0.2s 2}
        .status-dot.sent{background:#00ff88;animation:none}
        @keyframes pulse{0%,100%{opacity:0.6}50%{opacity:1}}
        @keyframes flash{0%,100%{opacity:0.3}50%{opacity:1}}
        
        /* =================================================================== */
        /* ---               PURPOSE-BUILT CIRCULAR UI                   --- */
        /* =================================================================== */
        .watch-container.circular-view { border-radius: 50%; }
        .watch-container.circular-view .watch-bezel { border-radius: 50%; }

        /* Swap to SVG Date */
        .watch-container.circular-view #date { opacity: 0 !important; visibility: hidden !important; }
        .watch-container.circular-view #date-svg { opacity: 0.8; visibility: visible; }

        /* AI/Map Focus Shift for Circle */
        .watch-container.circular-view.ai-visible #clock, 
        .watch-container.circular-view.map-visible #clock {
            transform: translateY(-115px) scale(0.6);
        }
        .watch-container.circular-view #ai-response { width: 80%; height: 65%; top: 52%; }
        .watch-container.circular-view #map-display { width: 100%; height: 100%; border-radius: 50%; }
        .watch-container.circular-view #map-display img { border-radius: 50%; }
    </style>
</head>
<body>
    <div class="watch-container" id="watchContainer">
        <div class="watch-bezel" id="watchBezel"></div>
        
        <div id="clock"></div>
        <div id="date"></div>

        <!-- Efficient SVG for curved date text in circular mode -->
        <svg id="date-svg" viewBox="0 0 300 300">
            <defs>
                <path id="datePath" d="M 60 150 a 90 90 0 1 1 180 0" fill="none" />
            </defs>
            <text>
                <textPath xlink:href="#datePath" startOffset="50%" text-anchor="middle">
                    LOADING...
                </textPath>
            </text>
        </svg>

        <div id="ai-response"></div>
        <div id="map-display">
            <img src="https://raw.githubusercontent.com/Success009/portfolio/refs/heads/main/exam/new-political-map-of-Nepal-1024x678.jpg" alt="Nepal Political Map">
        </div>
        
        <!-- Indicators -->
        <div id="battery">85%</div>
        <div class="status-dot" id="statusDot"></div>
        <div id="model-indicator">M4</div>
    </div>

    <script>
        // --- State Variables ---
        let currentMode='english',sharedMemory=[],recognition,isHolding=false,holdTimeout,batteryLevel=85,micActive=false,isProcessing=false,currentModelIndex=3,isCircularView=false;
        let answerHistory = [];
        let currentHistoryIndex = -1;
        let apiAbortController;
        let aiResponseFontSize = 1.0;
        let wakeLock = null;

        // --- DOM Element References ---
        const clock=document.getElementById('clock'),date=document.getElementById('date'),aiResponse=document.getElementById('ai-response'),mapDisplay=document.getElementById('map-display'),battery=document.getElementById('battery'),watchContainer=document.getElementById('watchContainer'),statusDot=document.getElementById('statusDot'),modelIndicator=document.getElementById('model-indicator'),watchBezel=document.getElementById('watchBezel'),dateSvgTextPath=document.querySelector("#date-svg textPath");
        
        const apiKeys = [ 'AIzaSyAnWImDSecI2NFYRtnpk98hwkEvK72HTG4', 'AIzaSyAydVv1BnKnKIsjXkBqqlqC3YJ8Z7R2J2c', 'AIzaSyBfsnu2FEGgChaQ2W6-pRJEh4xU0prjZY' ];
        let currentApiKeyIndex = 0;

        const aiModels = [
            { name: 'gemini-3-pro-preview', displayName: 'Gemini 3 Pro', indicator: 'M1' },
            { name: 'gemini-2.5-pro', displayName: 'Gemini 2.5 Pro', indicator: 'M2' },
            { name: 'gemini-2.5-flash', displayName: 'Gemini 2.5 Flash', indicator: 'M3' },
            { name: 'gemini-2.5-flash-lite', displayName: 'Gemini 2.5 Flash-Lite', indicator: 'M4' },
            { name: 'gemini-2.0-flash', displayName: 'Gemini 2.0 Flash', indicator: 'M5' }
        ];

        // --- Core Functions ---
        function updateTime() {
            const now = new Date();
            clock.textContent = now.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });

            const dateString = now.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }).toUpperCase();
            date.textContent = dateString;
            if(dateSvgTextPath) dateSvgTextPath.textContent = dateString;
        }

        // --- Wake Lock ---
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('ðŸ’¡ Screen Wake Lock acquired');
                    wakeLock.addEventListener('release', () => console.log('ðŸ’¡ Screen Wake Lock released'));
                }
            } catch (err) { console.error(`Wake Lock Error: ${err.name}, ${err.message}`); }
        }

        // --- UI State Management ---
        function displayResponse(text, addToHistory = true){
            watchContainer.classList.remove('map-visible');
            if (addToHistory && text) {
                answerHistory.unshift(text);
                if (answerHistory.length > 20) answerHistory.pop();
                currentHistoryIndex = 0;
            }
            aiResponse.innerHTML = text;
            watchContainer.classList.add('ai-visible');
            aiResponse.scrollTop = 0;
        }

        function hideResponse(){
            watchContainer.classList.remove('ai-visible');
        }

        function displayMap(){
            watchContainer.classList.remove('ai-visible');
            watchContainer.classList.add('map-visible');
            console.log('ðŸ—ºï¸ Map displayed');
        }

        function hideMap(){
            watchContainer.classList.remove('map-visible');
        }

        function toggleCircularView() {
            isCircularView = !isCircularView;
            watchContainer.classList.toggle('circular-view');
            updateTime();

            const confirmationMessage = isCircularView ? "Circular view activated." : "Default view restored.";
            displayResponse(confirmationMessage, false);
            setTimeout(() => {
                if (aiResponse.innerHTML === confirmationMessage) {
                   hideResponse();
                }
            }, 1500);
        }

        // --- Feature Functions ---
        function loadPreferences(){
            const savedApiIndex=localStorage.getItem('smartwatch_api_key_index');
            const savedModelIndex=localStorage.getItem('smartwatch_model_index');
            if(savedApiIndex!==null){
                currentApiKeyIndex=parseInt(savedApiIndex);
                console.log(`ðŸ“¦ Loaded API Key Index: ${currentApiKeyIndex+1}/${apiKeys.length}`);
            }
            if(savedModelIndex!==null){
                currentModelIndex=parseInt(savedModelIndex);
                console.log(`ðŸ“¦ Loaded Model Index: ${currentModelIndex+1}/${aiModels.length} (${aiModels[currentModelIndex].displayName})`);
            }
            updateModelIndicator();
        }

        function savePreferences(){
            localStorage.setItem('smartwatch_api_key_index',currentApiKeyIndex.toString());
            localStorage.setItem('smartwatch_model_index',currentModelIndex.toString());
        }
        
        function updateModelIndicator(){
            modelIndicator.textContent=aiModels[currentModelIndex].indicator;
        }
        
        function showApiChangeNotification(){
            const message=`API Changed (${currentApiKeyIndex+1}/${apiKeys.length})`;
            displayResponse(message,false);
            setTimeout(()=>{if(aiResponse.innerHTML===message){hideResponse()}},2000);
        }

        function showModelChangeNotification(){
            statusDot.className='status-dot model-change';
            const modelName=aiModels[currentModelIndex].displayName;
            const message=`Model Changed: ${modelName}`;
            displayResponse(message,false);
            setTimeout(()=>{statusDot.className=micActive?'status-dot active':'status-dot';if(aiResponse.innerHTML===message){hideResponse()}},2500);
        }

        function displayModels(){
            let modelList='';
            aiModels.forEach((model,index)=>{
                const isCurrent=index===currentModelIndex;
                const prefix=isCurrent?`<span class="current">${index+1}  ${model.displayName}</span>`:`${index+1}  ${model.displayName}`;
                modelList+=prefix+'\n';
            });
            displayResponse(`<div class="model-list">${modelList}</div>`);
        }

        function selectModel(modelNumber){
            const index=modelNumber-1;
            if(index>=0&&index<aiModels.length){
                currentModelIndex=index;
                updateModelIndicator();
                savePreferences();
                showModelChangeNotification();
                console.log(`ðŸ¤– Model changed to: ${aiModels[currentModelIndex].displayName}`);
            }
        }
        
        function displaySpelling(word){
            const cleanWord=word.trim().toLowerCase();
            hideMap();
            const spellingHtml=`<div class="spelling-display">${cleanWord}</div>`;
            displayResponse(spellingHtml);
            console.log(`âœï¸ Spelling displayed: ${cleanWord}`);
        }
        
        function switchMode(){
            currentMode=currentMode==='english'?'nepali':'english';
            statusDot.className='status-dot mode-change';
            setTimeout(()=>{
                statusDot.className=micActive?'status-dot active':'status-dot';
                if(recognition){
                    recognition.stop();
                    setTimeout(()=>{if(micActive)initSpeechRecognition()},500);
                }
            },600);
        }
        
        async function tryApiRequest(fullQuery,apiKey){
            const currentModel=aiModels[currentModelIndex].name;
            apiAbortController=new AbortController();
            updateStatus('sent');
            const response=await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${currentModel}:generateContent?key=${apiKey}`,{
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body:JSON.stringify({contents:[{parts:[{text:fullQuery}]}]}),
                signal:apiAbortController.signal
            });
            if(!response.ok){
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response;
        }

        async function getAIResponse(question,language){
            try{
                const memoryContext=sharedMemory.length>0?`Context: [${sharedMemory.join(", ")}]. `:"";
                const languageInstruction=language==='nepali'?"Respond only in Nepali language.":"Respond only in English language.";
                const fullQuery=`${memoryContext}${languageInstruction} Core rules:\n- For formulas, reply only with the formula from Nepal's Class 10 Sangam Book. But give answer even if it is different.\n- For dates, search online and provide the most accurate date with a confidence level.\n- For grammar tasks (e.g. question tag, passive, indirect, tense, etc.), reply with the correct transformed sentence only, as per Nepal Class 10 English rules. Interpret bracketed hints as instructions.\n- For all else, respond clearly and concisely.\n- If I ask you full form fine from class 10 Nepal sangam publication, If you don't know the exact contents of the book, just provide a correct answer.\nQuestion: ${question}`;
                console.log(`ðŸ¤– AI Request (${language}) using ${aiModels[currentModelIndex].displayName}:`,question);
                console.log(`ðŸ”‘ Using API Key Index: ${currentApiKeyIndex+1}/${apiKeys.length}`);
                let response;
                let attempts=0;
                const maxAttempts=apiKeys.length;
                while(attempts<maxAttempts){
                    try{
                        response=await tryApiRequest(fullQuery,apiKeys[currentApiKeyIndex]);
                        break;
                    }catch(error){
                        if(error.name==='AbortError'){return null}
                        console.log(`âŒ API Key ${currentApiKeyIndex+1} failed:`,error.message);
                        if(error.message.includes('429')){
                            console.log(`ðŸ”„ Switching to next API key due to rate limit...`);
                            currentApiKeyIndex=(currentApiKeyIndex+1)%apiKeys.length;
                            savePreferences();
                            attempts++;
                            showApiChangeNotification();
                            if(attempts<maxAttempts){
                                console.log(`ðŸ”‘ Trying API Key Index: ${currentApiKeyIndex+1}/${apiKeys.length}`);
                                continue;
                            }
                        }else{
                            throw error;
                        }
                    }
                }
                if(!response){throw new Error('All API keys exhausted due to rate limits')}
                const data=await response.json();
                const aiAnswer=data.candidates[0].content.parts[0].text.trim();
                console.log(`ðŸ¤– AI Response:`,aiAnswer);
                console.log(`âœ… Successfully used API Key Index: ${currentApiKeyIndex+1} with Model: ${aiModels[currentModelIndex].displayName}`);
                return aiAnswer;
            }catch(error){
                if(error.name==='AbortError'){return null}
                console.log(`ðŸ¤– AI Error:`,error.message);
                if(error.message.includes('All API keys exhausted')){
                    return"All API keys rate limited. Please try again later.";
                }else{
                    return"Service unavailable.";
                }
            }
        }
        
        function displayAnswerFromHistory(index){
            if(answerHistory.length>0&&index>=0&&index<answerHistory.length){
                currentHistoryIndex=index;
                displayResponse(answerHistory[index],false);
                console.log(`ðŸ“š Displaying answer from history, index: ${index}`);
            }else{
                console.log(`ðŸ“š History navigation limit reached.`);
                const message='No older answers.';
                displayResponse(message,false);
                setTimeout(()=>{
                    if(currentHistoryIndex!==-1&&answerHistory[currentHistoryIndex]){
                        displayResponse(answerHistory[currentHistoryIndex],false)
                    }else if(answerHistory.length>0){
                        displayResponse(answerHistory[0],false)
                    }else{
                        hideResponse()
                    }
                },1500);
            }
        }
        
        function scrollResponse(direction){
            if(!watchContainer.classList.contains('ai-visible'))return;
            watchBezel.classList.add('scrolling');
            setTimeout(()=>watchBezel.classList.remove('scrolling'),500);
            const lineHeight=parseInt(window.getComputedStyle(aiResponse).lineHeight)||20;
            const scrollAmount=lineHeight*3;
            if(direction==='down'){
                aiResponse.scrollTop+=scrollAmount
            }else if(direction==='up'){
                aiResponse.scrollTop-=scrollAmount
            }
        }

        function adjustZoom(direction){
            const step=0.1;
            const minSize=0.6;
            const maxSize=2.0;
            if(direction==='in'&&aiResponseFontSize<maxSize){
                aiResponseFontSize+=step
            }else if(direction==='out'&&aiResponseFontSize>minSize){
                aiResponseFontSize-=step
            }
            aiResponseFontSize=Math.round(aiResponseFontSize*10)/10;
            aiResponse.style.fontSize=`${aiResponseFontSize}rem`;
            console.log(`ðŸ”Ž AI Response font size set to ${aiResponseFontSize}rem`);
        }
        
        function updateStatus(status){
            statusDot.className=`status-dot ${status}`;
        }

        function toggleMic(){
            if(isProcessing)return;
            micActive=!micActive;
            if(micActive){
                updateStatus('active');
                initSpeechRecognition();
            }else{
                updateStatus('');
                if(recognition)recognition.stop();
            }
        }
        
        function checkVoiceCommands(transcript){
            const lowerTranscript=transcript.toLowerCase();
            if(lowerTranscript.includes("zoom in")){console.log("ðŸŽ¤ Voice Command: Zoom In");adjustZoom('in');return true}
            if(lowerTranscript.includes("zoom out")){console.log("ðŸŽ¤ Voice Command: Zoom Out");adjustZoom('out');return true}
            if(lowerTranscript.includes("display view change")){console.log("ðŸŽ¤ Voice Command: Display View Change");toggleCircularView();return true}
            if(lowerTranscript.includes("display answer")){console.log("ðŸŽ¤ Voice Command: Display Answer");displayAnswerFromHistory(0);return true}
            if(lowerTranscript.includes("previous answer")){console.log("ðŸŽ¤ Voice Command: Previous Answer");displayAnswerFromHistory(currentHistoryIndex+1);return true}
            if(lowerTranscript.includes("next answer")){console.log("ðŸŽ¤ Voice Command: Next Answer");displayAnswerFromHistory(currentHistoryIndex-1);return true}
            if(lowerTranscript.includes("display map")){console.log("ðŸŽ¤ Voice Command: Display Map");displayMap();return true}
            if(lowerTranscript.includes("scroll down")){console.log("ðŸŽ¤ Voice Command: Scroll Down");scrollResponse('down');return true}
            if(lowerTranscript.includes("scroll up")){console.log("ðŸŽ¤ Voice Command: Scroll Up");scrollResponse('up');return true}
            if(lowerTranscript.includes("spelling of")){const word=transcript.replace(/spelling of\s+/i,"").trim();if(word){console.log(`ðŸŽ¤ Voice Command: Spelling of "${word}"`);displaySpelling(word)}return true}
            if(lowerTranscript.includes("display models")){console.log("ðŸŽ¤ Voice Command: Display Models");displayModels();return true}
            const selectModelMatch=lowerTranscript.match(/select model (one|first|second|third|fourth|fifth|\d+)/);
            if(selectModelMatch){const identifier=selectModelMatch[1];const ordinals={'one':1,'first':1,'second':2,'third':3,'fourth':4,'fifth':5};let modelNumber=ordinals[identifier]||parseInt(identifier);if(!isNaN(modelNumber)){console.log(`ðŸŽ¤ Voice Command: Select Model ${modelNumber} (from "${identifier}")`);selectModel(modelNumber);return true}}
            if(lowerTranscript.includes("remember ")){const memoryContent=transcript.replace(/remember\s+/i,"").trim();if(memoryContent){sharedMemory.push(memoryContent);if(sharedMemory.length>15)sharedMemory.shift();console.log("ðŸ§  Memory Added:",memoryContent);displayResponse(`Remembered: "${memoryContent}"`)}return true}
            if(lowerTranscript.includes("clear memory")){sharedMemory=[];console.log("ðŸ§  Memory Cleared");displayResponse("Memory cleared.");return true}
            return false;
        }

        function initSpeechRecognition(){
            if(!micActive||!('webkitSpeechRecognition'in window)&&!('SpeechRecognition'in window))return;
            recognition=new(window.SpeechRecognition||window.webkitSpeechRecognition)();
            recognition.continuous=true;
            recognition.interimResults=false;
            recognition.lang=currentMode==='nepali'?'ne-NP':'en-US';
            recognition.onstart=()=>updateStatus('listening');
            recognition.onresult=(event)=>{
                const transcript=event.results[event.results.length-1][0].transcript.trim();
                isProcessing=true;
                updateStatus('heard');
                setTimeout(async()=>{
                    if(!isProcessing)return;
                    if(checkVoiceCommands(transcript)){
                        isProcessing=false;
                        updateStatus(micActive?'active':'');
                        return;
                    }
                    let question='';
                    if(currentMode==='nepali'&&transcript.includes('à¤®à¤²à¤¾à¤ˆ à¤­à¤¨')){
                        question=transcript.replace(/à¤®à¤²à¤¾à¤ˆ à¤­à¤¨/gi,'').trim();
                    }else if(transcript.toLowerCase().startsWith('listen')){
                        question=transcript.substring('listen'.length).trim();
                    }
                    if(question){
                        console.log(`ðŸŽ¤ Question (${currentMode} Mode): ${question}`);
                        const answer=await getAIResponse(question,currentMode);
                        if(answer!==null)displayResponse(answer);
                    }
                    isProcessing=false;
                    updateStatus(micActive?'active':'');
                },400);
            };
            recognition.onerror=()=>{
                isProcessing=false;
                updateStatus(micActive?'active':'');
            };
            recognition.onend=()=>{
                if(micActive&&!isHolding){
                    setTimeout(()=>{
                        if(micActive&&!isProcessing)try{recognition.start()}catch(e){}
                    },500);
                }else{
                    updateStatus(micActive?'active':'');
                }
            };
            try{recognition.start()}catch(e){}
        }
        
        // --- Event Listeners ---
        mapDisplay.addEventListener('click', hideMap);
        let touchStartTime=0;
        function startHold(e){
            e.preventDefault();
            isHolding=true;
            touchStartTime=Date.now();
            holdTimeout=setTimeout(()=>{
                if(isHolding)switchMode();
            },5000);
        }
        function endHold(e){
            e.preventDefault();
            isHolding=false;
            if(holdTimeout)clearTimeout(holdTimeout);
            const holdDuration=Date.now()-touchStartTime;
            if(holdDuration<500){
                if(isProcessing){
                    if(apiAbortController)apiAbortController.abort();
                    isProcessing=false;
                    updateStatus(micActive?'active':'');
                    console.log('ðŸš« User tapped to cancel processing.');
                    return;
                }
                if(watchContainer.classList.contains('ai-visible')){
                    hideResponse();
                }else if(watchContainer.classList.contains('map-visible')){
                    hideMap();
                }else{
                    toggleMic();
                }
            }
        }
        watchContainer.addEventListener('touchstart',startHold,{passive:false});
        watchContainer.addEventListener('touchend',endHold,{passive:false});
        watchContainer.addEventListener('touchcancel',endHold,{passive:false});
        watchContainer.addEventListener('mousedown',startHold);
        watchContainer.addEventListener('mouseup',endHold);
        watchContainer.addEventListener('mouseleave',endHold);
        watchContainer.addEventListener('contextmenu',e=>e.preventDefault());
        
        // --- Re-acquire Wake Lock on visibility change ---
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

        // --- Initialization ---
        function init(){
            loadPreferences();
            updateTime();
            requestWakeLock();
            setInterval(updateTime,1000);
            console.log(`ðŸš€ Smart Watch initialized.`);
            console.log(`ðŸš€ Default model set to: Gemini 2.5 Flash-Lite (Model 4)`);
        }
        init();
    </script>
</body>
</html>
