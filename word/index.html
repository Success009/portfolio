<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Imposter</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .game {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            position: relative;
        }

        .title {
            font-size: min(8vw, 2.5rem);
            margin-bottom: 2vh;
            color: #0ff;
        }

        .dots {
            display: flex;
            gap: 1vw;
            margin: 2vh 0;
        }

        .dot {
            width: min(3vw, 12px);
            height: min(3vw, 12px);
            background: #0ff;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .dot:nth-child(2) { animation-delay: 0.3s; }
        .dot:nth-child(3) { animation-delay: 0.6s; }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        .word {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #0ff;
            color: #fff;
            padding: min(6vw, 2.5rem);
            border-radius: min(3vw, 1rem);
            font-size: min(10vw, 2.5rem);
            font-weight: 800;
            margin: 3vh 0;
            box-shadow: 0 0 min(6vw, 1.5rem) rgba(0,255,255,0.3);
            transition: all 0.3s ease;
            max-width: 90vw;
            word-break: break-word;
            min-height: min(25vh, 200px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .imposter {
            background: linear-gradient(135deg, #2d1b69, #8b1538);
            border-color: #f0f;
            box-shadow: 0 0 min(6vw, 1.5rem) rgba(255,0,255,0.3);
        }

        .word.hidden {
            opacity: 0;
            transform: scale(0.9);
        }

        .status {
            font-size: min(4vw, 1rem);
            color: #0ff;
            margin: 1vh 0;
            opacity: 0.8;
        }

        .players {
            font-size: min(3vw, 0.8rem);
            color: #888;
            position: absolute;
            bottom: 2vh;
            opacity: 0.6;
        }

        .config {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #0ff;
            padding: min(5vw, 1.2rem);
            border-radius: min(2vw, 0.8rem);
            box-shadow: 0 0 min(8vw, 2rem) rgba(0,255,255,0.4);
            display: none;
            z-index: 1000;
            width: min(85vw, 18rem);
            max-height: 85vh;
            overflow-y: auto;
        }

        .config h3 {
            font-size: min(4.5vw, 1.1rem);
            margin-bottom: min(3vw, 0.8rem);
            color: #0ff;
        }

        .config-item {
            margin-bottom: min(2.5vw, 0.7rem);
        }

        .config-label {
            display: block;
            font-size: min(3.2vw, 0.75rem);
            color: #0ff;
            margin-bottom: min(1vw, 0.25rem);
        }

        .config-input, .config-select {
            width: 100%;
            padding: min(2vw, 0.4rem);
            border: 1px solid #333;
            border-radius: min(1vw, 0.25rem);
            background: #111;
            color: #fff;
            font-size: min(3vw, 0.75rem);
        }

        .config-input:focus, .config-select:focus {
            outline: none;
            border-color: #0ff;
        }

        .range-display {
            text-align: center;
            font-size: min(2.8vw, 0.65rem);
            color: #888;
            margin-top: min(1vw, 0.2rem);
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: min(2vw, 0.4rem);
            margin: min(2vw, 0.4rem) 0;
        }

        .checkbox-item input {
            width: min(3.5vw, 0.9rem);
            height: min(3.5vw, 0.9rem);
        }

        .checkbox-item label {
            font-size: min(2.8vw, 0.65rem);
        }

        .save-btn {
            background: linear-gradient(45deg, #0ff, #f0f);
            color: #000;
            border: none;
            padding: min(2.5vw, 0.7rem);
            border-radius: min(1.5vw, 0.4rem);
            width: 100%;
            font-size: min(3.5vw, 0.9rem);
            font-weight: 600;
            cursor: pointer;
            margin-top: min(2vw, 0.8rem);
        }

        .loading::after {
            content: '';
            animation: dots 2s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
    </style>
</head>
<body>
    <div class="game" id="game">
        <h1 class="title">Word Imposter</h1>
        <div class="dots" id="animation">
            <div class="dot"></div>
            <div class="dot"></div>
            <div class="dot"></div>
        </div>
        <div class="status" id="status">Tap to start</div>
        <div class="players" id="players"></div>
    </div>

    <div class="config" id="config">
        <h3>Settings</h3>
        <div class="config-item">
            <label class="config-label">Imposters:</label>
            <input type="range" class="config-input" id="imposters" min="1" max="10" value="1">
            <div class="range-display" id="impostersDisplay">1</div>
        </div>
        <div class="config-item">
            <label class="config-label">Category:</label>
            <select class="config-select" id="category">
                <option value="mixed">Mixed</option>
                <option value="animals">Animals</option>
                <option value="countries">Countries</option>
                <option value="objects">Objects</option>
                <option value="food">Food</option>
            </select>
        </div>
        <div class="config-item">
            <label class="config-label">Difficulty:</label>
            <select class="config-select" id="difficulty">
                <option value="easy">Easy</option>
                <option value="medium">Medium</option>
                <option value="hard">Hard</option>
            </select>
        </div>
        <div class="config-item">
            <div class="checkbox-item">
                <input type="checkbox" id="randomImposters">
                <label>Random Imposters (0 to max)</label>
            </div>
        </div>
        <button class="save-btn" onclick="saveConfig()">Save</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.0/firebase-app.js";
        import { getDatabase, ref, onValue, set, get, remove } from "https://www.gstatic.com/firebasejs/9.6.0/firebase-database.js";
        
        const app = initializeApp({
            apiKey: "AIzaSyA6sANvYoAkXHYG8MjbZl6Pyq23CNdBuzA",
            authDomain: "community-canvas-255fa.firebaseapp.com",
            databaseURL: "https://community-canvas-255fa-default-rtdb.firebaseio.com",
            projectId: "community-canvas-255fa",
            storageBucket: "community-canvas-255fa.appspot.com",
            messagingSenderId: "729445267995",
            appId: "1:729445267995:web:05da6756d66c58b9ccd6be"
        });
        
        const db = getDatabase(app);
        const GAME_NODE = 'wordImposterGame';
        
        // Persistent device ID
        let deviceId = localStorage.getItem('wordImposterDeviceId');
        if (!deviceId) {
            deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('wordImposterDeviceId', deviceId);
        }
        
        let processing = false;
        let longPress = null;
        let heartbeat = null;
        let cleanup = null;
        let visible = true;
        let gameData = null;
        let audioCtx;

        const game = document.getElementById('game');
        const status = document.getElementById('status');
        const players = document.getElementById('players');
        const config = document.getElementById('config');
        const animation = document.getElementById('animation');

        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function ding() {
            initAudio();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(800, audioCtx.currentTime);
            osc.frequency.setValueAtTime(1200, audioCtx.currentTime + 0.15);
            gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.6);
        }

        function startHeartbeat() {
            const send = () => set(ref(db, `${GAME_NODE}/players/${deviceId}`), { timestamp: Date.now() });
            send();
            const loop = () => {
                heartbeat = setTimeout(() => { send(); loop(); }, Math.random() * 4000 + 6000);
            };
            loop();
        }

        function startCleanup() {
            const clean = () => {
                get(ref(db, `${GAME_NODE}/players`)).then(snap => {
                    const p = snap.val() || {};
                    const now = Date.now();
                    for (const [id, data] of Object.entries(p)) {
                        if (now - data.timestamp > 15000) {
                            remove(ref(db, `${GAME_NODE}/players/${id}`));
                        }
                    }
                });
            };
            const loop = () => {
                cleanup = setTimeout(() => { clean(); loop(); }, Math.random() * 15000 + 10000);
            };
            loop();
        }

        async function getWord() {
            const cfg = await get(ref(db, `${GAME_NODE}/config`));
            const c = cfg.val() || { category: 'mixed', difficulty: 'easy' };
            
            let catPrompt = '';
            switch(c.category) {
                case 'animals': catPrompt = 'animal'; break;
                case 'countries': catPrompt = 'country'; break;
                case 'objects': catPrompt = 'object'; break;
                case 'food': catPrompt = 'food'; break;
                default: catPrompt = 'word';
            }

            const prompt = `Generate one ${c.difficulty} ${catPrompt} for guessing game. Just the word.`;
            
            const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyAioo23YXTQAxFZ9J5OGlzd3WrjPYW9IEY`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { maxOutputTokens: 5, temperature: 0.9 }
                })
            });

            const data = await res.json();
            return data.candidates[0].content.parts[0].text.trim().toLowerCase();
        }

        async function getActivePlayers() {
            const snap = await get(ref(db, `${GAME_NODE}/players`));
            const p = snap.val() || {};
            const now = Date.now();
            return Object.keys(p).filter(id => now - p[id].timestamp < 15000);
        }

        async function startGame() {
            if (processing) return;
            processing = true;

            try {
                status.innerHTML = 'Getting word<span class="loading"></span>';
                animation.style.display = 'none';

                const word = await getWord();
                const activePlayers = await getActivePlayers();
                
                if (activePlayers.length < 3) {
                    status.textContent = 'Need 3+ players';
                    animation.style.display = 'flex';
                    processing = false;
                    setTimeout(() => status.textContent = 'Tap to start', 3000);
                    return;
                }

                const cfg = await get(ref(db, `${GAME_NODE}/config`));
                const c = cfg.val() || { imposters: 1, randomImposters: false };
                
                const shuffled = [...activePlayers].sort(() => Math.random() - 0.5);
                let numImposters;
                
                if (c.randomImposters) {
                    numImposters = Math.floor(Math.random() * (activePlayers.length - 1)); // 0 to (players-1)
                } else {
                    numImposters = Math.min(parseInt(c.imposters || 1), activePlayers.length - 1);
                }
                
                const imposters = shuffled.slice(0, numImposters);

                await set(ref(db, `${GAME_NODE}/currentGame`), {
                    word,
                    players: activePlayers,
                    imposters,
                    timestamp: Date.now()
                });
                
            } catch (error) {
                status.textContent = 'Error';
                animation.style.display = 'flex';
                processing = false;
                setTimeout(() => status.textContent = 'Tap to start', 3000);
            }
        }

        function showResult(word, isImposter) {
            ding();
            gameData = { word, isImposter };

            game.innerHTML = `
                <div class="word ${isImposter ? 'imposter' : ''}" id="wordDisplay">
                    ${isImposter ? 
                        '<div><div style="font-size: 1.5em; margin-bottom: 0.3em;">üïµÔ∏è</div><div>IMPOSTER</div><div style="font-size: 0.6em; margin-top: 0.3em; opacity: 0.8;">Blend in!</div></div>' :
                        `<div><div style="font-size: 0.6em; margin-bottom: 0.3em; opacity: 0.8;">Word:</div><div style="text-transform: uppercase;">${word}</div><div style="font-size: 0.6em; margin-top: 0.3em; opacity: 0.8;">Find imposters!</div></div>`
                    }
                </div>
                <div class="status" id="status">Tap for new game</div>
                <div class="players" id="players"></div>
            `;

            processing = false;
            visible = true;
            updatePlayers();
        }

        function toggleVisibility() {
            if (!gameData) return;
            const wordEl = document.getElementById('wordDisplay');
            if (wordEl) {
                visible = !visible;
                wordEl.classList.toggle('hidden', !visible);
            }
        }

        function updatePlayers() {
            onValue(ref(db, `${GAME_NODE}/players`), snap => {
                const p = snap.val() || {};
                const now = Date.now();
                const count = Object.values(p).filter(data => now - data.timestamp < 15000).length;
                const playersEl = document.getElementById('players');
                if (playersEl) playersEl.textContent = `${count} active`;
                
                // Update imposter range max
                const impostersInput = document.getElementById('imposters');
                if (impostersInput && count > 0) {
                    const maxImposters = Math.max(1, count - 1);
                    impostersInput.max = maxImposters;
                    if (parseInt(impostersInput.value) > maxImposters) {
                        impostersInput.value = maxImposters;
                        updateRange();
                    }
                }
            });
        }

        function updateRange() {
            const impostersInput = document.getElementById('imposters');
            const display = document.getElementById('impostersDisplay');
            if (display) display.textContent = impostersInput.value;
        }

        async function loadConfig() {
            try {
                const cfg = await get(ref(db, `${GAME_NODE}/config`));
                const c = cfg.val();
                if (c) {
                    document.getElementById('imposters').value = c.imposters || 1;
                    document.getElementById('category').value = c.category || 'mixed';
                    document.getElementById('difficulty').value = c.difficulty || 'easy';
                    document.getElementById('randomImposters').checked = c.randomImposters || false;
                    updateRange();
                } else {
                    // Set defaults
                    await set(ref(db, `${GAME_NODE}/config`), {
                        imposters: 1,
                        category: 'mixed',
                        difficulty: 'easy',
                        randomImposters: false
                    });
                }
            } catch (e) {
                // Set defaults on error
                await set(ref(db, `${GAME_NODE}/config`), {
                    imposters: 1,
                    category: 'mixed',
                    difficulty: 'easy',
                    randomImposters: false
                });
            }
        }

        function showConfig() {
            config.style.display = 'block';
            loadConfig();
        }

        window.saveConfig = async function() {
            const c = {
                imposters: parseInt(document.getElementById('imposters').value),
                category: document.getElementById('category').value,
                difficulty: document.getElementById('difficulty').value,
                randomImposters: document.getElementById('randomImposters').checked
            };
            await set(ref(db, `${GAME_NODE}/config`), c);
            config.style.display = 'none';
        };

        // Event listeners
        document.getElementById('imposters').addEventListener('input', updateRange);
        
        // Listen for config changes
        onValue(ref(db, `${GAME_NODE}/config`), snap => {
            const c = snap.val();
            if (c && config.style.display === 'none') {
                document.getElementById('imposters').value = c.imposters || 1;
                document.getElementById('category').value = c.category || 'mixed';
                document.getElementById('difficulty').value = c.difficulty || 'easy';
                document.getElementById('randomImposters').checked = c.randomImposters || false;
                updateRange();
            }
        });
        
        // Listen for game updates
        onValue(ref(db, `${GAME_NODE}/currentGame`), snap => {
            const data = snap.val();
            if (data && Date.now() - data.timestamp < 30000) {
                if (data.players.includes(deviceId)) {
                    showResult(data.word, data.imposters.includes(deviceId));
                }
            }
        });

        game.addEventListener('touchstart', e => {
            e.preventDefault();
            initAudio();
            longPress = setTimeout(() => showConfig(), 5000);
            if (gameData) toggleVisibility();
            else if (!processing) startGame();
        });

        game.addEventListener('touchend', e => {
            e.preventDefault();
            if (longPress) { clearTimeout(longPress); longPress = null; }
        });

        game.addEventListener('mousedown', e => {
            e.preventDefault();
            initAudio();
            longPress = setTimeout(() => showConfig(), 5000);
            if (gameData) toggleVisibility();
            else if (!processing) startGame();
        });

        game.addEventListener('mouseup', e => {
            e.preventDefault();
            if (longPress) { clearTimeout(longPress); longPress = null; }
        });

        // Initialize
        startHeartbeat();
        startCleanup();
        updatePlayers();
        loadConfig();
    </script>
</body>
</html>
