<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Imposter</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:-apple-system,BlinkMacSystemFont,sans-serif;background:#000;color:#fff;height:100vh;overflow:hidden;display:flex;align-items:center;justify-content:center;-webkit-tap-highlight-color: transparent;}
        .game{width:100vw;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;position:relative; user-select: none;}
        .title{font-size:min(8vw,2.5rem);margin-bottom:2vh;color:#0ff}
        .dots{display:flex;gap:1vw;margin:2vh 0}
        .dot{width:min(3vw,12px);height:min(3vw,12px);background:#0ff;border-radius:50%;animation:pulse 2s infinite}
        .dot:nth-child(2){animation-delay:.3s}
        .dot:nth-child(3){animation-delay:.6s}
        @keyframes pulse{0%,100%{opacity:.3;transform:scale(.8)}50%{opacity:1;transform:scale(1.2)}}
        .word{background:linear-gradient(135deg,#1a1a2e,#16213e);border:2px solid #0ff;color:#fff;padding:min(6vw,2.5rem);border-radius:min(3vw,1rem);font-size:min(10vw,2.5rem);font-weight:800;margin:3vh 0;box-shadow:0 0 min(6vw,1.5rem) rgba(0,255,255,.3);transition:all .3s ease;max-width:90vw;word-break:break-word;min-height:min(25vh,200px);display:flex;align-items:center;justify-content:center;flex-direction:column}
        .imposter{background:linear-gradient(135deg,#2d1b69,#8b1538);border-color:#f0f;box-shadow:0 0 min(6vw,1.5rem) rgba(255,0,255,.3)}
        .unknown-imposter{background:linear-gradient(135deg,#1a1a2e,#16213e);border:2px solid #0ff;box-shadow:0 0 min(6vw,1.5rem) rgba(0,255,255,.3)}
        .starter{background:linear-gradient(135deg,#1b692d,#38b15b);border-color:#0f0;box-shadow:0 0 min(6vw,1.5rem) rgba(0,255,0,.3)}
        .word.hidden{opacity:0;transform:scale(.9); pointer-events: none;}
        .status{font-size:min(4vw,1rem);color:#0ff;margin:1vh 0;opacity:.8}
        .players{font-size:min(3vw,.8rem);color:#888;position:absolute;bottom:2vh;opacity:.6}
        .config{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(135deg,#1a1a2e,#16213e);border:2px solid #0ff;padding:min(4vw,1rem);border-radius:min(2vw,.8rem);box-shadow:0 0 min(8vw,2rem) rgba(0,255,255,.4);display:none;z-index:1000;width:min(90vw,20rem);max-height:90vh;overflow-y:auto}
        .config h3{font-size:min(4vw,1rem);margin-bottom:min(2vw,.6rem);color:#0ff;text-align:center}
        .config-item{margin-bottom:min(2vw,.5rem)}
        .config-label{display:block;font-size:min(3vw,.7rem);color:#0ff;margin-bottom:min(1vw,.2rem)}
        .config-input,.config-select{width:100%;padding:min(1.5vw,.3rem);border:1px solid #333;border-radius:min(1vw,.2rem);background:#111;color:#fff;font-size:min(2.8vw,.65rem)}
        .config-input:focus,.config-select:focus{outline:none;border-color:#0ff}
        .range-display{text-align:center;font-size:min(2.5vw,.6rem);color:#888;margin-top:min(.5vw,.1rem)}
        .checkbox-item{display:flex;align-items:center;gap:min(1.5vw,.3rem);margin:min(1.5vw,.3rem) 0}
        .checkbox-item input{width:min(3vw,.8rem);height:min(3vw,.8rem)}
        .checkbox-item label{font-size:min(2.5vw,.6rem)}
        .btn{background:linear-gradient(45deg,#0ff,#f0f);color:#000;border:none;padding:min(2vw,.6rem);border-radius:min(1vw,.3rem);width:100%;font-size:min(3vw,.8rem);font-weight:600;cursor:pointer;margin-top:min(1.5vw,.5rem)}
        .start-btn{background:linear-gradient(45deg,#0f0,#0a0);margin-bottom:min(2vw,.5rem)}
        .loading::after{content:'';animation:dots 2s infinite}
        @keyframes dots{0%,20%{content:'.'}40%{content:'..'}60%,100%{content:'...'}}
        .turn-indicator{font-size:min(3vw,.8rem);color:#0f0;margin-bottom:min(2vw,.5rem);padding:min(1vw,.3rem);background:rgba(0,255,0,.1);border:1px solid #0f0;border-radius:min(1vw,.3rem)}
        .heartbeat-display{font-size:min(2vw,.5rem);color:#666;position:absolute;top:1vh;right:1vw}
        .feature-highlight{background:linear-gradient(45deg,#ff6600,#ff9900);color:#000;font-weight:bold;padding:min(1vw,.2rem);border-radius:min(.5vw,.1rem);margin-left:min(1vw,.2rem);font-size:min(2vw,.5rem)}
    </style>
</head>
<body>
    <div class="game" id="game">
        <h1 class="title">Word Imposter</h1>
        <div class="dots" id="animation">
            <div class="dot"></div>
            <div class="dot"></div>
            <div class="dot"></div>
        </div>
        <div class="status" id="status">Love; Love ‚ù§Ô∏è</div>
        <div class="players" id="players"></div>
        <div class="heartbeat-display" id="heartbeat">‚ô•</div>
    </div>

    <div class="config" id="config">
        <h3>Game Settings</h3>
        <button class="btn start-btn" onclick="startGameFromConfig()">üéØ START NEW GAME</button>

        <div class="config-item">
            <label class="config-label">Imposters:</label>
            <input type="range" class="config-input" id="imposters" min="1" max="10" value="1">
            <div class="range-display" id="impostersDisplay">1</div>
        </div>

        <div class="config-item">
            <div class="checkbox-item">
                <input type="checkbox" id="unknownImposter" checked>
                <label>üé≠ Unknown Imposter</label>
            </div>
        </div>

        <div class="config-item">
            <label class="config-label">Category:</label>
            <select class="config-select" id="category" disabled>
                <option value="mixed">üé≤ Simple Words (Default)</option>
            </select>
        </div>

        <div class="config-item">
            <div class="checkbox-item">
                <input type="checkbox" id="useAI" disabled>
                <label>ü§ñ Use AI (Needs valid API key)</label>
            </div>
        </div>

        <button class="btn" onclick="saveConfig()">üíæ Save Settings</button>
        <button class="btn" onclick="closeConfig()" style="background:linear-gradient(45deg,#666,#999);margin-top:.3rem">‚ùå Close</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
        import { getDatabase, ref, onValue, set, get, remove } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

        const firebaseConfig = {apiKey:"AIzaSyA6sANvYoAkXHYG8MjbZl6Pyq23CNdBuzA",authDomain:"community-canvas-255fa.firebaseapp.com",databaseURL:"https://community-canvas-255fa-default-rtdb.firebaseio.com",projectId:"community-canvas-255fa",storageBucket:"community-canvas-255fa.appspot.com",messagingSenderId:"729445267995",appId:"1:729445267995:web:05da6756d66c58b9ccd6be"};
        const GEMINI_API_KEY = "AIzaSyCVhh967ATShWvPX0jjh2sbruzWTxEGXL4"; // NOTE: This key is invalid and will cause errors if AI is enabled.

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const GAME_NODE = 'wordImposterGame';

        let deviceId = localStorage.getItem('wordImposterDeviceId');
        if (!deviceId) {
            deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('wordImposterDeviceId', deviceId);
        }

        let processing = false;
        let longPressTimer = null;
        let longPressFired = false;
        let heartbeatTimeout = null;
        let cleanupTimeout = null;
        let isWordVisible = true;
        let currentGameData = null;
        let audioCtx;
        const heartbeatInterval = 4; // seconds

        const gameEl = document.getElementById('game');
        const statusEl = document.getElementById('status');
        const playersEl = document.getElementById('players');
        const configEl = document.getElementById('config');
        const animationEl = document.getElementById('animation');
        const heartbeatEl = document.getElementById('heartbeat');

        function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        function ding() {
            initAudio();
            const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(800, audioCtx.currentTime);
            osc.frequency.setValueAtTime(1200, audioCtx.currentTime + .15);
            gain.gain.setValueAtTime(.4, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(.01, audioCtx.currentTime + .6);
            osc.start(); osc.stop(audioCtx.currentTime + .6);
        }

        function startHeartbeat() {
            if (heartbeatTimeout) clearTimeout(heartbeatTimeout);
            const send = () => {
                set(ref(db, `${GAME_NODE}/players/${deviceId}`), { timestamp: Date.now() });
                heartbeatEl.style.color = '#0f0';
                setTimeout(() => heartbeatEl.style.color = '#666', 200);
            };
            send();
            const loop = () => {
                heartbeatTimeout = setTimeout(() => {
                    send();
                    loop();
                }, heartbeatInterval * 1000 + Math.random() * 1000);
            };
            loop();
        }

        function startCleanup() {
            if (cleanupTimeout) clearTimeout(cleanupTimeout);
            const clean = () => {
                get(ref(db, `${GAME_NODE}/players`)).then(snap => {
                    const p = snap.val() || {}, now = Date.now();
                    for (const [id, data] of Object.entries(p)) {
                        if (now - data.timestamp > heartbeatInterval * 3 * 1000) {
                            remove(ref(db, `${GAME_NODE}/players/${id}`));
                        }
                    }
                });
            };
            const loop = () => {
                cleanupTimeout = setTimeout(() => {
                    clean();
                    loop();
                }, heartbeatInterval * 2 * 1000 + Math.random() * 5000);
            };
            loop();
        }

        async function getWord(isForImposter = false, mainWord = null) {
            const cfgSnap = await get(ref(db, `${GAME_NODE}/config`));
            const c = cfgSnap.val() || { category: 'mixed', useAI: false };
            
            if (c.useAI) {
                let prompt;
                if (isForImposter && mainWord) {
                    prompt = `Generate one very simple, basic word that everyone knows, but make it DIFFERENT from "${mainWord}". Avoid words in the same category as "${mainWord}". Examples: dog, cat, tree, car, house, book, sun, water, fire, bird. Respond with ONLY the word, nothing else. Make it simple and common but different.`;
                } else {
                    prompt = 'Generate one very simple, basic word that everyone knows. Examples: dog, cat, tree, car, house, book, sun, water, fire, bird. Respond with ONLY the word, nothing else. Make it simple and common.';
                }
                
                try {
                    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }], generationConfig: { maxOutputTokens: 5, temperature: .8 } })
                    });
                    const data = await res.json();
                    return data.candidates[0].content.parts[0].text.trim().toLowerCase().replace(/[^\w\s-]/g, '');
                } catch (e) {
                    console.error("AI word generation failed. Falling back to local list.", e);
                }
            }
            
            const words = ['dog', 'cat', 'tree', 'car', 'house', 'book', 'sun', 'water', 'fire', 'bird', 'fish', 'lion', 'bear', 'wolf', 'fox', 'deer', 'horse', 'cow', 'pig', 'sheep', 'chicken', 'duck', 'rabbit', 'mouse', 'elephant', 'tiger', 'monkey', 'snake', 'frog', 'bee', 'spider', 'flower', 'grass', 'mountain', 'river', 'ocean', 'lake', 'forest', 'desert', 'rock', 'sand', 'cloud', 'rain', 'snow', 'wind', 'storm', 'moon', 'star', 'planet', 'earth', 'apple', 'banana', 'orange', 'bread', 'milk', 'cheese', 'pizza', 'cake', 'cookie', 'tea', 'coffee', 'juice', 'chair', 'table', 'bed', 'door', 'window', 'phone', 'computer', 'bike', 'bus', 'train', 'plane', 'boat', 'ball', 'toy', 'game', 'music', 'dance', 'sing', 'run', 'walk', 'jump', 'swim', 'fly', 'red', 'blue', 'green', 'yellow', 'black', 'white', 'pink', 'purple', 'orange', 'brown', 'big', 'small', 'hot', 'cold', 'fast', 'slow', 'happy', 'sad', 'love', 'friend', 'school', 'park', 'shop', 'home', 'work', 'play', 'food', 'drink', 'sleep', 'wake', 'light', 'dark', 'up', 'down', 'left', 'right', 'new', 'old', 'good', 'bad', 'yes', 'no', 'stop', 'go', 'come', 'here', 'there', 'baby', 'child', 'man', 'woman', 'boy', 'girl', 'mother', 'father', 'brother', 'sister', 'hand', 'foot', 'head', 'eye', 'ear', 'nose', 'mouth', 'hair', 'face', 'smile', 'laugh', 'cry', 'help', 'thank', 'sorry', 'please'];
            
            if (isForImposter && mainWord) {
                // Filter out the main word and try to avoid similar words
                const filtered = words.filter(w => w !== mainWord);
                return filtered[Math.floor(Math.random() * filtered.length)];
            }
            
            return words[Math.floor(Math.random() * words.length)];
        }

        async function getActivePlayers() {
            const snap = await get(ref(db, `${GAME_NODE}/players`));
            const p = snap.val() || {}, now = Date.now();
            return Object.keys(p).filter(id => now - p[id].timestamp < heartbeatInterval * 3 * 1000);
        }

        async function startGame() {
            if (processing) return;
            processing = true;
            try {
                statusEl.innerHTML = 'Getting word<span class="loading"></span>';
                animationEl.style.display = 'none';
                
                const activePlayers = await getActivePlayers();
                if (activePlayers.length < 3) {
                    statusEl.textContent = 'Need 3+ players';
                    animationEl.style.display = 'flex';
                    setTimeout(() => statusEl.textContent = 'Love; Love ‚ù§Ô∏è', 3000);
                    processing = false;
                    return;
                }
                
                const cfgSnap = await get(ref(db, `${GAME_NODE}/config`));
                const c = cfgSnap.val() || { imposters: 1, unknownImposter: true };
                
                const shuffled = [...activePlayers].sort(() => Math.random() - .5);
                let numImposters = Math.min(parseInt(c.imposters || 1), activePlayers.length - 1);
                if (numImposters < 1) numImposters = 1;
                
                const imposters = shuffled.slice(0, numImposters);
                const starter = shuffled[Math.floor(Math.random() * shuffled.length)];
                
                // Get the main word for normal players
                const mainWord = await getWord();
                
                let gameData = {
                    word: mainWord,
                    players: activePlayers,
                    imposters,
                    starter,
                    timestamp: Date.now(),
                    unknownImposter: c.unknownImposter || false
                };
                
                // If unknown imposter is enabled, generate different words for imposters
                if (c.unknownImposter) {
                    gameData.imposterWords = {};
                    for (const imposter of imposters) {
                        gameData.imposterWords[imposter] = await getWord(true, mainWord);
                    }
                }
                
                await set(ref(db, `${GAME_NODE}/currentGame`), gameData);
            } catch (error) {
                console.error("Error starting game:", error);
                statusEl.textContent = 'Error starting game';
                animationEl.style.display = 'flex';
                setTimeout(() => statusEl.textContent = 'Love; Love ‚ù§Ô∏è', 3000);
            } finally {
                processing = false;
            }
        }

        function showResult(gameData, deviceId) {
            ding();
            const isImposter = gameData.imposters.includes(deviceId);
            const isStarter = gameData.starter === deviceId;
            const unknownImposter = gameData.unknownImposter || false;
            
            let displayWord = gameData.word;
            let showAsImposter = false;
            
            // Determine what to show based on unknown imposter setting
            if (unknownImposter) {
                // Unknown imposter mode - imposters get different word but don't know they're imposters
                if (isImposter && gameData.imposterWords && gameData.imposterWords[deviceId]) {
                    displayWord = gameData.imposterWords[deviceId];
                }
                // Everyone appears as normal player in unknown mode
                showAsImposter = false;
            } else {
                // Classic mode - imposters know they're imposters
                showAsImposter = isImposter;
            }
            
            currentGameData = { 
                word: displayWord, 
                isImposter, 
                isStarter, 
                showAsImposter,
                unknownImposter
            };
            
            const starterClass = isStarter ? 'starter' : '';
            const imposterClass = showAsImposter ? 'imposter' : '';
            const combinedClass = `${starterClass} ${imposterClass}`.trim();
            
            let roleDisplay = '';
            if (showAsImposter) {
                // Classic imposter display
                roleDisplay = '<div><div style="font-size:1.5em;margin-bottom:.3em">üïµÔ∏è</div><div>IMPOSTER</div><div style="font-size:.6em;margin-top:.3em;opacity:.8">Blend in & guess the word!</div></div>';
            } else {
                // Normal player display (including unknown imposters)
                roleDisplay = `<div><div style="font-size:.6em;margin-bottom:.3em;opacity:.8">Word:</div><div style="text-transform:uppercase">${displayWord}</div><div style="font-size:.6em;margin-top:.3em;opacity:.8">Find the imposters!</div></div>`;
            }
            
            gameEl.innerHTML = `<div class="word ${combinedClass}" id="wordDisplay">${isStarter ? '<div class="turn-indicator">üéØ YOU START FIRST!<br>Give the first hint</div>' : ''}${roleDisplay}</div><div class="status" id="status">Tap to hide/show ‚Ä¢ Hold for config</div><div class="players" id="players"></div><div class="heartbeat-display" id="heartbeat">‚ô•</div>`;
            
            isWordVisible = true;
            updatePlayersDisplay();
        }

        function toggleVisibility() {
            if (!currentGameData) return;
            const wordEl = document.getElementById('wordDisplay');
            if (wordEl) {
                isWordVisible = !isWordVisible;
                wordEl.classList.toggle('hidden', !isWordVisible);
            }
        }

        function updatePlayersDisplay() {
            onValue(ref(db, `${GAME_NODE}/players`), snap => {
                const p = snap.val() || {}, now = Date.now();
                const count = Object.values(p).filter(data => now - data.timestamp < heartbeatInterval * 3 * 1000).length;
                const playersEl_inner = document.getElementById('players');
                if (playersEl_inner) playersEl_inner.textContent = `${count} players online`;

                const impostersInput = document.getElementById('imposters');
                if (impostersInput && count > 0) {
                    impostersInput.max = Math.max(1, count - 1);
                    if (parseInt(impostersInput.value) > impostersInput.max) {
                        impostersInput.value = impostersInput.max;
                    }
                    updateRangeDisplay('imposters');
                }
            });
        }

        function updateRangeDisplay(type) {
            if (type === 'imposters') {
                document.getElementById('impostersDisplay').textContent = document.getElementById('imposters').value;
            }
        }

        async function loadConfig() {
            try {
                const cfgSnap = await get(ref(db, `${GAME_NODE}/config`));
                const c = cfgSnap.val();
                if (c) {
                    document.getElementById('imposters').value = c.imposters || 1;
                    document.getElementById('useAI').checked = c.useAI || false;
                    document.getElementById('unknownImposter').checked = c.unknownImposter !== undefined ? c.unknownImposter : true;
                    updateRangeDisplay('imposters');
                } else {
                    await set(ref(db, `${GAME_NODE}/config`), { imposters: 1, useAI: false, unknownImposter: true });
                }
            } catch (e) {
                await set(ref(db, `${GAME_NODE}/config`), { imposters: 1, useAI: false, unknownImposter: true });
            }
        }

        function showConfig() { configEl.style.display = 'block'; loadConfig(); }
        function closeConfig() { configEl.style.display = 'none'; }

        window.saveConfig = async function () {
            const c = { 
                imposters: parseInt(document.getElementById('imposters').value), 
                useAI: document.getElementById('useAI').checked,
                unknownImposter: document.getElementById('unknownImposter').checked
            };
            await set(ref(db, `${GAME_NODE}/config`), c);
            configEl.style.display = 'none';
        };

        window.closeConfig = closeConfig;
        window.startGameFromConfig = function () { configEl.style.display = 'none'; if (!processing) startGame(); };

        document.getElementById('imposters').addEventListener('input', () => updateRangeDisplay('imposters'));

        onValue(ref(db, `${GAME_NODE}/currentGame`), snap => {
            const data = snap.val();
            if (data && Date.now() - data.timestamp < 60000) {
                if (data.players.includes(deviceId)) {
                    showResult(data, deviceId);
                }
            }
        });

        ['touchstart', 'mousedown'].forEach(event => {
            gameEl.addEventListener(event, e => {
                e.preventDefault();
                initAudio();
                longPressFired = false;
                longPressTimer = setTimeout(() => {
                    longPressFired = true;
                    showConfig();
                }, 1000);
            });
        });

        ['touchend', 'mouseup', 'mouseleave'].forEach(event => {
            gameEl.addEventListener(event, e => {
                e.preventDefault();
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                if (!longPressFired && currentGameData) {
                    toggleVisibility();
                }
            });
        });

        startHeartbeat();
        startCleanup();
        updatePlayersDisplay();
        loadConfig();
    </script>
</body>
</html>

