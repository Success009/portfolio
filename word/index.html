<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Imposter</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:-apple-system,BlinkMacSystemFont,sans-serif;background:#000;color:#fff;height:100vh;overflow:hidden;display:flex;align-items:center;justify-content:center;-webkit-tap-highlight-color: transparent;}
        .game{width:100vw;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;position:relative; user-select: none;}
        .title{font-size:min(8vw,2.5rem);margin-bottom:2vh;color:#0ff}
        .dots{display:flex;gap:1vw;margin:2vh 0}
        .dot{width:min(3vw,12px);height:min(3vw,12px);background:#0ff;border-radius:50%;animation:pulse 2s infinite}
        .dot:nth-child(2){animation-delay:.3s}
        .dot:nth-child(3){animation-delay:.6s}
        @keyframes pulse{0%,100%{opacity:.3;transform:scale(.8)}50%{opacity:1;transform:scale(1.2)}}
        .word{background:linear-gradient(135deg,#1a1a2e,#16213e);border:2px solid #0ff;color:#fff;padding:min(6vw,2.5rem);border-radius:min(3vw,1rem);font-size:min(10vw,2.5rem);font-weight:800;margin:3vh 0;box-shadow:0 0 min(6vw,1.5rem) rgba(0,255,255,.3);transition:all .3s ease;max-width:90vw;word-break:break-word;min-height:min(25vh,200px);display:flex;align-items:center;justify-content:center;flex-direction:column}
        .imposter{background:linear-gradient(135deg,#2d1b69,#8b1538);border-color:#f0f;box-shadow:0 0 min(6vw,1.5rem) rgba(255,0,255,.3)}
        .starter{background:linear-gradient(135deg,#1b692d,#38b15b);border-color:#0f0;box-shadow:0 0 min(6vw,1.5rem) rgba(0,255,0,.3)}
        .word.hidden{opacity:0;transform:scale(.9); pointer-events: none;}
        .status{font-size:min(4vw,1rem);color:#0ff;margin:1vh 0;opacity:.8;min-height:1.2em;}
        .players{font-size:min(3vw,.8rem);color:#888;position:absolute;bottom:2vh;opacity:.6}
        .config{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(135deg,#1a1a2e,#16213e);border:2px solid #0ff;padding:min(4vw,1rem);border-radius:min(2vw,.8rem);box-shadow:0 0 min(8vw,2rem) rgba(0,255,255,.4);display:none;z-index:1000;width:min(90vw,20rem);max-height:90vh;overflow-y:auto}
        .config h3{font-size:min(4vw,1rem);margin-bottom:min(2vw,.6rem);color:#0ff;text-align:center}
        .config-item{margin-bottom:min(2vw,.5rem)}
        .config-label{display:block;font-size:min(3vw,.7rem);color:#0ff;margin-bottom:min(1vw,.2rem)}
        .config-input,.config-select{width:100%;padding:min(1.5vw,.3rem);border:1px solid #333;border-radius:min(1vw,.2rem);background:#111;color:#fff;font-size:min(2.8vw,.65rem)}
        .config-input:focus,.config-select:focus{outline:none;border-color:#0ff}
        .range-display{text-align:center;font-size:min(2.5vw,.6rem);color:#888;margin-top:min(.5vw,.1rem)}
        .checkbox-item{display:flex;align-items:center;gap:min(1.5vw,.3rem);margin:min(1.5vw,.3rem) 0}
        .checkbox-item input{width:min(3vw,.8rem);height:min(3vw,.8rem)}
        .checkbox-item label{font-size:min(2.5vw,.6rem)}
        .btn{background:linear-gradient(45deg,#0ff,#f0f);color:#000;border:none;padding:min(2vw,.6rem);border-radius:min(1vw,.3rem);width:100%;font-size:min(3vw,.8rem);font-weight:600;cursor:pointer;margin-top:min(1.5vw,.5rem)}
        .start-btn{background:linear-gradient(45deg,#0f0,#0a0);margin-bottom:min(2vw,.5rem)}
        .loading::after{content:'';animation:dots 2s infinite}
        @keyframes dots{0%,20%{content:'.'}40%{content:'..'}60%,100%{content:'...'}}
        .turn-indicator{font-size:min(3vw,.8rem);color:#0f0;margin-bottom:min(2vw,.5rem);padding:min(1vw,.3rem);background:rgba(0,255,0,.1);border:1px solid #0f0;border-radius:min(1vw,.3rem)}
        .heartbeat-display{font-size:min(2vw,.5rem);color:#666;position:absolute;top:1vh;right:1vw}
    </style>
</head>
<body>
    <div class="game" id="game">
        <h1 class="title">Word Imposter</h1>
        <div class="dots" id="animation">
            <div class="dot"></div>
            <div class="dot"></div>
            <div class="dot"></div>
        </div>
        <div class="status" id="status">Love; Love ‚ù§Ô∏è</div>
        <div class="players" id="players"></div>
        <div class="heartbeat-display" id="heartbeat">‚ô•</div>
    </div>

    <div class="config" id="config">
        <h3>Game Settings</h3>
        <button class="btn start-btn" onclick="startGameFromConfig()">üéØ START NEW GAME</button>

        <div class="config-item">
            <label class="config-label">Imposters:</label>
            <input type="range" class="config-input" id="imposters" min="1" max="10" value="1">
            <div class="range-display" id="impostersDisplay">1</div>
        </div>

        <div class="config-item">
            <div class="checkbox-item">
                <input type="checkbox" id="unknownImposter" checked>
                <label for="unknownImposter">üé≠ Unknown Imposter Mode</label>
            </div>
        </div>

        <div class="config-item">
            <label class="config-label">Category:</label>
            <select class="config-select" id="category">
                <option value="simple">üé≤ Simple Words</option>
                <option value="animals">üê∂ Animals</option>
                <option value="objects">üöó Objects</option>
                <option value="food">üçï Food</option>
            </select>
        </div>

        <div class="config-item">
            <div class="checkbox-item">
                <input type="checkbox" id="useAI" checked>
                <label for="useAI">ü§ñ Use AI for Words</label>
            </div>
        </div>

        <button class="btn" onclick="saveConfig()">üíæ Save Settings</button>
        <button class="btn" onclick="closeConfig()" style="background:linear-gradient(45deg,#666,#999);margin-top:.3rem">‚ùå Close</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
        import { getDatabase, ref, onValue, set, get, remove } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

        // --- WARNING: DO NOT USE A REAL KEY HERE ON A PUBLIC WEBSITE ---
        // This key is visible to anyone who views the page source.
        const GEMINI_API_KEY = "AIzaSyCVhh967ATShWvPX0jjh2sbruzWTxEGXL4";

        const firebaseConfig = {apiKey:"AIzaSyA6sANvYoAkXHYG8MjbZl6Pyq23CNdBuzA",authDomain:"community-canvas-255fa.firebaseapp.com",databaseURL:"https://community-canvas-255fa-default-rtdb.firebaseio.com",projectId:"community-canvas-255fa",storageBucket:"community-canvas-255fa.appspot.com",messagingSenderId:"729445267995",appId:"1:729445267995:web:05da6756d66c58b9ccd6be"};
        
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const GAME_NODE = 'wordImposterGame';

        let deviceId = localStorage.getItem('wordImposterDeviceId');
        if (!deviceId) {
            deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('wordImposterDeviceId', deviceId);
        }

        let processing = false;
        let longPressTimer = null;
        let longPressFired = false;
        let heartbeatTimeout = null;
        let cleanupTimeout = null;
        let isWordVisible = true;
        let currentGameData = null;
        let audioCtx;
        const heartbeatInterval = 4; // seconds

        const gameEl = document.getElementById('game');
        const statusEl = document.getElementById('status');
        const playersEl = document.getElementById('players');
        const configEl = document.getElementById('config');
        const animationEl = document.getElementById('animation');
        const heartbeatEl = document.getElementById('heartbeat');

        function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        function ding() {
            initAudio();
            const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(800, audioCtx.currentTime);
            osc.frequency.setValueAtTime(1200, audioCtx.currentTime + .15);
            gain.gain.setValueAtTime(.4, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(.01, audioCtx.currentTime + .6);
            osc.start(); osc.stop(audioCtx.currentTime + .6);
        }

        function startHeartbeat() {
            if (heartbeatTimeout) clearTimeout(heartbeatTimeout);
            const send = () => {
                set(ref(db, `${GAME_NODE}/players/${deviceId}`), { timestamp: Date.now() });
                heartbeatEl.style.color = '#0f0';
                setTimeout(() => heartbeatEl.style.color = '#666', 200);
            };
            send();
            const loop = () => {
                heartbeatTimeout = setTimeout(() => {
                    send();
                    loop();
                }, heartbeatInterval * 1000 + Math.random() * 1000);
            };
            loop();
        }

        function startCleanup() {
            if (cleanupTimeout) clearTimeout(cleanupTimeout);
            const clean = () => {
                get(ref(db, `${GAME_NODE}/players`)).then(snap => {
                    const p = snap.val() || {}, now = Date.now();
                    for (const [id, data] of Object.entries(p)) {
                        if (now - data.timestamp > heartbeatInterval * 3 * 1000) {
                            remove(ref(db, `${GAME_NODE}/players/${id}`));
                        }
                    }
                });
            };
            const loop = () => {
                cleanupTimeout = setTimeout(() => {
                    clean();
                    loop();
                }, heartbeatInterval * 2 * 1000 + Math.random() * 5000);
            };
            loop();
        }

        async function getWord(isForImposter = false, mainWord = null) {
            const cfgSnap = await get(ref(db, `${GAME_NODE}/config`));
            const c = cfgSnap.val() || { category: 'simple', useAI: true };
            const apiKey = GEMINI_API_KEY;

            if (c.useAI && apiKey) {
                const category_map = {
                    'simple': 'a simple, common, everyday word',
                    'animals': 'a simple, common animal',
                    'objects': 'a simple, common household or everyday object',
                    'food': 'a simple, common food item'
                };
                const category_desc = category_map[c.category] || category_map['simple'];
                let prompt;

                if (isForImposter && mainWord) {
                    prompt = `The main word for the other players is "${mainWord}", which is in the category of "${category_desc}". Generate a different, but also very simple and common word, from a COMPLETELY DIFFERENT category (e.g., if the category is animals, suggest an object or food). The word must be one word only. Respond with ONLY the word.`;
                } else {
                    prompt = `Generate one word that is ${category_desc}. It must be a very common, single word that a child would know. Examples: dog, car, apple, house. Respond with ONLY the single word, nothing else.`;
                }
                
                try {
                    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }], generationConfig: { maxOutputTokens: 10, temperature: 0.9 } })
                    });
                    if (!res.ok) throw new Error(`API request failed with status ${res.status}`);
                    
                    const data = await res.json();
                    // Robust check for a valid response from the API
                    if (data.candidates && data.candidates.length > 0) {
                        const word = data.candidates[0].content.parts[0].text.trim().toLowerCase().replace(/[^\w\s-]/g, '').split(' ')[0];
                        if (word) return word;
                    }
                    throw new Error("API returned no valid candidates or an empty word.");

                } catch (e) {
                    console.error("AI word generation failed. Falling back to local list.", e);
                    statusEl.textContent = 'AI Error! Using backup words.';
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }
            
            // Fallback logic
            const words = ['dog','cat','tree','car','house','book','sun','water','fire','bird','fish','lion','bear','wolf','fox','horse','cow','pig','sheep','chicken','duck','rabbit','mouse','elephant','tiger','monkey','snake','frog','bee','spider','flower','grass','mountain','river','ocean','lake','forest','rock','sand','cloud','rain','snow','wind','moon','star','earth','apple','banana','orange','bread','milk','cheese','pizza','cake','cookie','tea','coffee','juice','chair','table','bed','door','window','phone','computer','bike','bus','train','plane','boat','ball','toy','game','music','love','friend','school','home','work','play','food','drink','sleep','light','dark','up','down','left','right','new','old','good','bad','baby','child','man','woman','boy','girl','mother','father','hand','foot','head','eye','nose','mouth','hair','face','smile','laugh','cry','help'];
            if (isForImposter && mainWord) {
                const filtered = words.filter(w => w !== mainWord);
                return filtered[Math.floor(Math.random() * filtered.length)];
            }
            return words[Math.floor(Math.random() * words.length)];
        }

        async function getActivePlayers() {
            const snap = await get(ref(db, `${GAME_NODE}/players`));
            const p = snap.val() || {}, now = Date.now();
            return Object.keys(p).filter(id => now - p[id].timestamp < heartbeatInterval * 3 * 1000);
        }

        async function startGame() {
            if (processing) return;
            processing = true;
            try {
                const cfgSnap = await get(ref(db, `${GAME_NODE}/config`));
                const c = cfgSnap.val() || { imposters: 1, unknownImposter: true, useAI: true };
                const AImode = c.useAI && GEMINI_API_KEY ? ' (using AI)' : '';
                statusEl.innerHTML = `Getting word${AImode}<span class="loading"></span>`;
                animationEl.style.display = 'none';
                
                const activePlayers = await getActivePlayers();
                if (activePlayers.length < 3) {
                    statusEl.textContent = 'Need 3+ players';
                    animationEl.style.display = 'flex';
                    setTimeout(() => statusEl.textContent = 'Love; Love ‚ù§Ô∏è', 3000);
                    processing = false;
                    return;
                }
                                
                const shuffled = [...activePlayers].sort(() => Math.random() - .5);
                let numImposters = Math.min(parseInt(c.imposters || 1), activePlayers.length - 1);
                if (numImposters < 1) numImposters = 1;
                
                const imposters = shuffled.slice(0, numImposters);
                const starter = shuffled[Math.floor(Math.random() * shuffled.length)];
                
                const mainWord = await getWord();
                
                let gameData = {
                    word: mainWord,
                    players: activePlayers,
                    imposters,
                    starter,
                    timestamp: Date.now(),
                    unknownImposter: c.unknownImposter || false
                };
                
                if (c.unknownImposter) {
                    gameData.imposterWords = {};
                    for (const imposter of imposters) {
                        gameData.imposterWords[imposter] = await getWord(true, mainWord);
                    }
                }
                
                await set(ref(db, `${GAME_NODE}/currentGame`), gameData);
            } catch (error) {
                console.error("Error starting game:", error);
                statusEl.textContent = 'Error starting game';
                animationEl.style.display = 'flex';
                setTimeout(() => statusEl.textContent = 'Love; Love ‚ù§Ô∏è', 3000);
            } finally {
                processing = false;
            }
        }

        function showResult(gameData, deviceId) {
            ding();
            const isImposter = gameData.imposters.includes(deviceId);
            const isStarter = gameData.starter === deviceId;
            const unknownImposter = gameData.unknownImposter || false;
            
            let displayWord = gameData.word;
            let showAsImposter = false;
            
            if (unknownImposter) {
                if (isImposter && gameData.imposterWords && gameData.imposterWords[deviceId]) {
                    displayWord = gameData.imposterWords[deviceId];
                }
                showAsImposter = false;
            } else {
                showAsImposter = isImposter;
            }
            
            currentGameData = { word: displayWord, isImposter, isStarter, showAsImposter, unknownImposter };
            
            const starterClass = isStarter ? 'starter' : '';
            const imposterClass = showAsImposter ? 'imposter' : '';
            const combinedClass = `${starterClass} ${imposterClass}`.trim();
            
            let roleDisplay = '';
            if (showAsImposter) {
                roleDisplay = '<div><div style="font-size:1.5em;margin-bottom:.3em">üïµÔ∏è</div><div>IMPOSTER</div><div style="font-size:.6em;margin-top:.3em;opacity:.8">Blend in & guess the word!</div></div>';
            } else {
                roleDisplay = `<div><div style="font-size:.6em;margin-bottom:.3em;opacity:.8">Your Word:</div><div style="text-transform:uppercase">${displayWord}</div><div style="font-size:.6em;margin-top:.3em;opacity:.8">Find the imposters!</div></div>`;
            }
            
            gameEl.innerHTML = `<div class="word ${combinedClass}" id="wordDisplay">${isStarter ? '<div class="turn-indicator">üéØ YOU START FIRST!<br>Give the first hint</div>' : ''}${roleDisplay}</div><div class="status" id="status">Tap to hide/show ‚Ä¢ Hold for config</div><div class="players" id="players"></div><div class="heartbeat-display" id="heartbeat">‚ô•</div>`;
            
            isWordVisible = true;
            updatePlayersDisplay();
        }

        function toggleVisibility() {
            if (!currentGameData) return;
            const wordEl = document.getElementById('wordDisplay');
            if (wordEl) {
                isWordVisible = !isWordVisible;
                wordEl.classList.toggle('hidden', !isWordVisible);
            }
        }

        function updatePlayersDisplay() {
            onValue(ref(db, `${GAME_NODE}/players`), snap => {
                const p = snap.val() || {}, now = Date.now();
                const count = Object.values(p).filter(data => now - data.timestamp < heartbeatInterval * 3 * 1000).length;
                const playersEl_inner = document.getElementById('players');
                if (playersEl_inner) playersEl_inner.textContent = `${count} players online`;

                const impostersInput = document.getElementById('imposters');
                if (impostersInput && count > 0) {
                    impostersInput.max = Math.max(1, count - 1);
                    if (parseInt(impostersInput.value) > impostersInput.max) {
                        impostersInput.value = impostersInput.max;
                    }
                    updateRangeDisplay('imposters');
                }
            });
        }

        function updateRangeDisplay(type) {
            if (type === 'imposters') {
                document.getElementById('impostersDisplay').textContent = document.getElementById('imposters').value;
            }
        }

        async function loadConfig() {
            try {
                const cfgSnap = await get(ref(db, `${GAME_NODE}/config`));
                const c = cfgSnap.val();
                if (c) {
                    document.getElementById('imposters').value = c.imposters || 1;
                    document.getElementById('useAI').checked = c.useAI !== undefined ? c.useAI : true;
                    document.getElementById('unknownImposter').checked = c.unknownImposter !== undefined ? c.unknownImposter : true;
                    document.getElementById('category').value = c.category || 'simple';
                    updateRangeDisplay('imposters');
                } else {
                     await set(ref(db, `${GAME_NODE}/config`), { imposters: 1, useAI: true, unknownImposter: true, category: 'simple' });
                }
            } catch (e) {
                 await set(ref(db, `${GAME_NODE}/config`), { imposters: 1, useAI: true, unknownImposter: true, category: 'simple' });
            }
        }

        function showConfig() { configEl.style.display = 'block'; loadConfig(); }
        window.closeConfig = function() { configEl.style.display = 'none'; }

        window.saveConfig = async function () {
            const c = { 
                imposters: parseInt(document.getElementById('imposters').value), 
                useAI: document.getElementById('useAI').checked,
                unknownImposter: document.getElementById('unknownImposter').checked,
                category: document.getElementById('category').value
            };
            await set(ref(db, `${GAME_NODE}/config`), c);
            closeConfig();
        };

        window.startGameFromConfig = function () { closeConfig(); if (!processing) startGame(); };

        document.getElementById('imposters').addEventListener('input', () => updateRangeDisplay('imposters'));
        
        onValue(ref(db, `${GAME_NODE}/currentGame`), snap => {
            const data = snap.val();
            if (data && Date.now() - data.timestamp < 60000) {
                if (data.players.includes(deviceId)) {
                    showResult(data, deviceId);
                }
            }
        });

        ['touchstart', 'mousedown'].forEach(event => {
            gameEl.addEventListener(event, e => {
                e.preventDefault();
                initAudio();
                longPressFired = false;
                longPressTimer = setTimeout(() => {
                    longPressFired = true;
                    showConfig();
                }, 1000);
            });
        });

        ['touchend', 'mouseup', 'mouseleave'].forEach(event => {
            gameEl.addEventListener(event, e => {
                e.preventDefault();
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                if (!longPressFired && currentGameData) {
                    toggleVisibility();
                }
            });
        });

        startHeartbeat();
        startCleanup();
        updatePlayersDisplay();
        loadConfig();
    </script>
</body>
</html>
